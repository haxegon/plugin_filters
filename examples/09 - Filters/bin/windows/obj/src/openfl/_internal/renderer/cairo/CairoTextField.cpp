// Generated by Haxe 3.4.4
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_lime_graphics_Image
#include <lime/graphics/Image.h>
#endif
#ifndef INCLUDED_lime_graphics_cairo_Cairo
#include <lime/graphics/cairo/Cairo.h>
#endif
#ifndef INCLUDED_lime_graphics_cairo_CairoGlyph
#include <lime/graphics/cairo/CairoGlyph.h>
#endif
#ifndef INCLUDED_lime_graphics_cairo__CairoFTFontFace_CairoFTFontFace_Impl_
#include <lime/graphics/cairo/_CairoFTFontFace/CairoFTFontFace_Impl_.h>
#endif
#ifndef INCLUDED_lime_graphics_cairo__CairoFontOptions_CairoFontOptions_Impl_
#include <lime/graphics/cairo/_CairoFontOptions/CairoFontOptions_Impl_.h>
#endif
#ifndef INCLUDED_lime_graphics_cairo__CairoImageSurface_CairoImageSurface_Impl_
#include <lime/graphics/cairo/_CairoImageSurface/CairoImageSurface_Impl_.h>
#endif
#ifndef INCLUDED_lime_math_Matrix3
#include <lime/math/Matrix3.h>
#endif
#ifndef INCLUDED_lime_math_Vector2
#include <lime/math/Vector2.h>
#endif
#ifndef INCLUDED_lime_text_Font
#include <lime/text/Font.h>
#endif
#ifndef INCLUDED_lime_text_GlyphPosition
#include <lime/text/GlyphPosition.h>
#endif
#ifndef INCLUDED_lime_text__UTF8String_UTF8String_Impl_
#include <lime/text/_UTF8String/UTF8String_Impl_.h>
#endif
#ifndef INCLUDED_openfl__Vector_AbstractVector
#include <openfl/_Vector/AbstractVector.h>
#endif
#ifndef INCLUDED_openfl__Vector_IVector
#include <openfl/_Vector/IVector.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_RenderSession
#include <openfl/_internal/renderer/RenderSession.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_cairo_CairoTextField
#include <openfl/_internal/renderer/cairo/CairoTextField.h>
#endif
#ifndef INCLUDED_openfl__internal_text_TextEngine
#include <openfl/_internal/text/TextEngine.h>
#endif
#ifndef INCLUDED_openfl__internal_text_TextLayoutGroup
#include <openfl/_internal/text/TextLayoutGroup.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_Graphics
#include <openfl/display/Graphics.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_IShaderDrawable
#include <openfl/display/IShaderDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_InteractiveObject
#include <openfl/display/InteractiveObject.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_filters_BitmapFilter
#include <openfl/filters/BitmapFilter.h>
#endif
#ifndef INCLUDED_openfl_filters_GlowFilter
#include <openfl/filters/GlowFilter.h>
#endif
#ifndef INCLUDED_openfl_geom_Matrix
#include <openfl/geom/Matrix.h>
#endif
#ifndef INCLUDED_openfl_geom_Rectangle
#include <openfl/geom/Rectangle.h>
#endif
#ifndef INCLUDED_openfl_text_Font
#include <openfl/text/Font.h>
#endif
#ifndef INCLUDED_openfl_text_TextField
#include <openfl/text/TextField.h>
#endif
#ifndef INCLUDED_openfl_text_TextFormat
#include <openfl/text/TextFormat.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_0e9241bd5d873906_36_render,"openfl._internal.renderer.cairo.CairoTextField","render",0xabb9797e,"openfl._internal.renderer.cairo.CairoTextField.render","openfl/_internal/renderer/cairo/CairoTextField.hx",36,0xfadfb778)
namespace openfl{
namespace _internal{
namespace renderer{
namespace cairo{

void CairoTextField_obj::__construct() { }

Dynamic CairoTextField_obj::__CreateEmpty() { return new CairoTextField_obj; }

void *CairoTextField_obj::_hx_vtable = 0;

Dynamic CairoTextField_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< CairoTextField_obj > _hx_result = new CairoTextField_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool CairoTextField_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x76dbe9c2;
}

void CairoTextField_obj::render( ::openfl::text::TextField textField, ::openfl::_internal::renderer::RenderSession renderSession, ::openfl::geom::Matrix transform){
            	HX_GC_STACKFRAME(&_hx_pos_0e9241bd5d873906_36_render)
HXLINE(  40)		 ::openfl::_internal::text::TextEngine textEngine = textField->_hx___textEngine;
HXLINE(  41)		 ::openfl::geom::Rectangle bounds = textEngine->bounds;
HXLINE(  42)		 ::openfl::display::Graphics graphics = textField->_hx___graphics;
HXLINE(  43)		 ::lime::graphics::cairo::Cairo cairo = graphics->_hx___cairo;
HXLINE(  45)		if (textField->_hx___dirty) {
HXLINE(  47)			textField->_hx___updateLayout();
HXLINE(  49)			if (hx::IsNull( graphics->_hx___bounds )) {
HXLINE(  51)				graphics->_hx___bounds =  ::openfl::geom::Rectangle_obj::__alloc( HX_CTX ,null(),null(),null(),null());
            			}
HXLINE(  55)			graphics->_hx___bounds->copyFrom(bounds);
            		}
HXLINE(  62)		graphics->_hx___update();
HXLINE(  64)		int width = graphics->_hx___width;
HXLINE(  65)		int height = graphics->_hx___height;
HXLINE(  67)		bool renderable;
HXDLIN(  67)		bool renderable1;
HXDLIN(  67)		if (!(textEngine->border)) {
HXLINE(  67)			renderable1 = textEngine->background;
            		}
            		else {
HXLINE(  67)			renderable1 = true;
            		}
HXDLIN(  67)		if (!(renderable1)) {
HXLINE(  67)			renderable = hx::IsNotNull( textEngine->text );
            		}
            		else {
HXLINE(  67)			renderable = true;
            		}
HXLINE(  69)		if (hx::IsNotNull( cairo )) {
HXLINE(  72)			 ::Dynamic surface = graphics->_hx___bitmap->getSurface();
HXLINE(  74)			bool _hx_tmp;
HXDLIN(  74)			if (!(!(renderable))) {
HXLINE(  74)				if (graphics->_hx___dirty) {
HXLINE(  74)					if ((width == ::lime::graphics::cairo::_CairoImageSurface::CairoImageSurface_Impl__obj::get_width(surface))) {
HXLINE(  74)						_hx_tmp = (height != ::lime::graphics::cairo::_CairoImageSurface::CairoImageSurface_Impl__obj::get_height(surface));
            					}
            					else {
HXLINE(  74)						_hx_tmp = true;
            					}
            				}
            				else {
HXLINE(  74)					_hx_tmp = false;
            				}
            			}
            			else {
HXLINE(  74)				_hx_tmp = true;
            			}
HXDLIN(  74)			if (_hx_tmp) {
HXLINE(  76)				graphics->_hx___cairo = null();
HXLINE(  77)				graphics->_hx___bitmap = null();
HXLINE(  78)				graphics->_hx___visible = false;
HXLINE(  79)				cairo = null();
            			}
            		}
HXLINE(  85)		bool _hx_tmp1;
HXDLIN(  85)		bool _hx_tmp2;
HXDLIN(  85)		bool _hx_tmp3;
HXDLIN(  85)		if ((width > (int)0)) {
HXLINE(  85)			_hx_tmp3 = (height <= (int)0);
            		}
            		else {
HXLINE(  85)			_hx_tmp3 = true;
            		}
HXDLIN(  85)		if (!(_hx_tmp3)) {
HXLINE(  85)			if (!(textField->_hx___dirty)) {
HXLINE(  85)				_hx_tmp2 = !(graphics->_hx___dirty);
            			}
            			else {
HXLINE(  85)				_hx_tmp2 = false;
            			}
            		}
            		else {
HXLINE(  85)			_hx_tmp2 = true;
            		}
HXDLIN(  85)		if (!(_hx_tmp2)) {
HXLINE(  85)			_hx_tmp1 = !(renderable);
            		}
            		else {
HXLINE(  85)			_hx_tmp1 = true;
            		}
HXDLIN(  85)		if (_hx_tmp1) {
HXLINE(  87)			textField->_hx___dirty = false;
HXLINE(  88)			return;
            		}
HXLINE(  92)		if (hx::IsNull( cairo )) {
HXLINE(  94)			 ::openfl::display::BitmapData bitmap =  ::openfl::display::BitmapData_obj::__alloc( HX_CTX ,width,height,true,(int)0);
HXLINE(  95)			 ::Dynamic surface1 = bitmap->getSurface();
HXLINE(  96)			graphics->_hx___cairo =  ::lime::graphics::cairo::Cairo_obj::__alloc( HX_CTX ,surface1);
HXLINE(  97)			graphics->_hx___visible = true;
HXLINE(  98)			graphics->_hx___managed = true;
HXLINE( 100)			graphics->_hx___bitmap = bitmap;
HXLINE( 102)			cairo = graphics->_hx___cairo;
HXLINE( 104)			 ::Dynamic options = ::lime::graphics::cairo::_CairoFontOptions::CairoFontOptions_Impl__obj::_new();
HXLINE( 106)			bool _hx_tmp4;
HXDLIN( 106)			if (hx::IsEq( textEngine->antiAliasType,(int)0 )) {
HXLINE( 106)				_hx_tmp4 = (textEngine->sharpness == (int)400);
            			}
            			else {
HXLINE( 106)				_hx_tmp4 = false;
            			}
HXDLIN( 106)			if (_hx_tmp4) {
HXLINE( 108)				::lime::graphics::cairo::_CairoFontOptions::CairoFontOptions_Impl__obj::set_hintStyle(options,(int)1);
HXLINE( 109)				::lime::graphics::cairo::_CairoFontOptions::CairoFontOptions_Impl__obj::set_hintMetrics(options,(int)1);
HXLINE( 110)				::lime::graphics::cairo::_CairoFontOptions::CairoFontOptions_Impl__obj::set_antialias(options,(int)1);
            			}
            			else {
HXLINE( 114)				::lime::graphics::cairo::_CairoFontOptions::CairoFontOptions_Impl__obj::set_hintStyle(options,(int)2);
HXLINE( 115)				::lime::graphics::cairo::_CairoFontOptions::CairoFontOptions_Impl__obj::set_hintMetrics(options,(int)1);
HXLINE( 116)				::lime::graphics::cairo::_CairoFontOptions::CairoFontOptions_Impl__obj::set_antialias(options,(int)5);
            			}
HXLINE( 120)			cairo->set_fontOptions(options);
            		}
HXLINE( 124)		{
HXLINE( 126)			 ::lime::math::Matrix3 matrix = graphics->_hx___renderTransform->_hx___toMatrix3();
HXLINE( 127)			matrix->tx = ::Math_obj::round(matrix->tx);
HXLINE( 128)			matrix->ty = ::Math_obj::round(matrix->ty);
HXLINE( 129)			cairo->set_matrix(matrix);
            		}
HXLINE( 137)		if (textEngine->border) {
HXLINE( 139)			int _hx_tmp5 = ::Std_obj::_hx_int((bounds->width - (int)1));
HXDLIN( 139)			cairo->rectangle(((Float)0.5),((Float)0.5),_hx_tmp5,::Std_obj::_hx_int((bounds->height - (int)1)));
            		}
            		else {
HXLINE( 143)			cairo->rectangle((int)0,(int)0,bounds->width,bounds->height);
            		}
HXLINE( 147)		if (!(textEngine->background)) {
HXLINE( 149)			cairo->set_operator((int)0);
HXLINE( 150)			cairo->paint();
HXLINE( 151)			cairo->set_operator((int)2);
            		}
            		else {
HXLINE( 155)			int color = textEngine->backgroundColor;
HXLINE( 156)			Float r = ((Float)hx::UShr(((int)color & (int)(int)16711680),(int)16) / (Float)(int)255);
HXLINE( 157)			Float g = ((Float)hx::UShr(((int)color & (int)(int)65280),(int)8) / (Float)(int)255);
HXLINE( 158)			Float b = ((Float)((int)color & (int)(int)255) / (Float)(int)255);
HXLINE( 160)			cairo->setSourceRGB(r,g,b);
HXLINE( 161)			cairo->fillPreserve();
            		}
HXLINE( 165)		if (textEngine->border) {
HXLINE( 167)			int color1 = textEngine->borderColor;
HXLINE( 168)			Float r1 = ((Float)hx::UShr(((int)color1 & (int)(int)16711680),(int)16) / (Float)(int)255);
HXLINE( 169)			Float g1 = ((Float)hx::UShr(((int)color1 & (int)(int)65280),(int)8) / (Float)(int)255);
HXLINE( 170)			Float b1 = ((Float)((int)color1 & (int)(int)255) / (Float)(int)255);
HXLINE( 172)			cairo->setSourceRGB(r1,g1,b1);
HXLINE( 173)			cairo->set_lineWidth((int)1);
HXLINE( 174)			cairo->stroke();
            		}
HXLINE( 178)		bool _hx_tmp6;
HXDLIN( 178)		if (hx::IsNotNull( textEngine->text )) {
HXLINE( 178)			_hx_tmp6 = (textEngine->text != HX_("",00,00,00,00));
            		}
            		else {
HXLINE( 178)			_hx_tmp6 = false;
            		}
HXDLIN( 178)		if (_hx_tmp6) {
HXLINE( 180)			Float bounds1 = bounds->width;
HXDLIN( 180)			int _hx_tmp7;
HXDLIN( 180)			if (textField->get_border()) {
HXLINE( 180)				_hx_tmp7 = (int)1;
            			}
            			else {
HXLINE( 180)				_hx_tmp7 = (int)0;
            			}
HXDLIN( 180)			Float _hx_tmp8 = (bounds1 - _hx_tmp7);
HXDLIN( 180)			Float bounds2 = bounds->height;
HXDLIN( 180)			int _hx_tmp9;
HXDLIN( 180)			if (textField->get_border()) {
HXLINE( 180)				_hx_tmp9 = (int)1;
            			}
            			else {
HXLINE( 180)				_hx_tmp9 = (int)0;
            			}
HXDLIN( 180)			cairo->rectangle((int)0,(int)0,_hx_tmp8,(bounds2 - _hx_tmp9));
HXLINE( 181)			cairo->clip();
HXLINE( 183)			::String text = textEngine->text;
HXLINE( 185)			int scrollX = -(textField->get_scrollH());
HXLINE( 186)			Float scrollY = ((Float)0.0);
HXLINE( 188)			{
HXLINE( 188)				int _g1 = (int)0;
HXDLIN( 188)				int _g = (textField->get_scrollV() - (int)1);
HXDLIN( 188)				while((_g1 < _g)){
HXLINE( 188)					_g1 = (_g1 + (int)1);
HXDLIN( 188)					int i = (_g1 - (int)1);
HXLINE( 190)					scrollY = (scrollY - ( (Float)(::openfl::_Vector::IVector_obj::get(textEngine->lineHeights->data,i)) ));
            				}
            			}
HXLINE( 194)			 ::Dynamic color2;
HXDLIN( 194)			Float r2;
HXDLIN( 194)			Float g2;
HXDLIN( 194)			Float b2;
HXDLIN( 194)			 ::openfl::text::Font font;
HXDLIN( 194)			int size;
HXDLIN( 194)			Float advance;
HXLINE( 196)			{
HXLINE( 196)				int _g2 = (int)0;
HXDLIN( 196)				 ::openfl::_Vector::AbstractVector _g11 = textEngine->layoutGroups;
HXDLIN( 196)				while((_g2 < ::openfl::_Vector::IVector_obj::get_length(_g11->data))){
HXLINE( 196)					 ::openfl::_internal::text::TextLayoutGroup group = ( ( ::openfl::_internal::text::TextLayoutGroup)(::openfl::_Vector::IVector_obj::get(_g11->data,_g2)) );
HXDLIN( 196)					_g2 = (_g2 + (int)1);
HXLINE( 198)					int group1 = group->lineIndex;
HXDLIN( 198)					if ((group1 < (textField->get_scrollV() - (int)1))) {
HXLINE( 198)						continue;
            					}
HXLINE( 199)					int group2 = group->lineIndex;
HXDLIN( 199)					int _hx_tmp10 = textField->get_scrollV();
HXDLIN( 199)					if ((group2 > ((_hx_tmp10 + textEngine->bottomScrollV) - (int)2))) {
HXLINE( 199)						goto _hx_goto_1;
            					}
HXLINE( 201)					color2 = group->format->color;
HXLINE( 202)					r2 = ((Float)hx::UShr(((int)color2 & (int)(int)16711680),(int)16) / (Float)(int)255);
HXLINE( 203)					g2 = ((Float)hx::UShr(((int)color2 & (int)(int)65280),(int)8) / (Float)(int)255);
HXLINE( 204)					b2 = ((Float)((int)color2 & (int)(int)255) / (Float)(int)255);
HXLINE( 206)					cairo->setSourceRGB(r2,g2,b2);
HXLINE( 208)					font = ::openfl::_internal::text::TextEngine_obj::getFontInstance(group->format);
HXLINE( 210)					bool _hx_tmp11;
HXDLIN( 210)					if (hx::IsNotNull( font )) {
HXLINE( 210)						_hx_tmp11 = hx::IsNotNull( group->format->size );
            					}
            					else {
HXLINE( 210)						_hx_tmp11 = false;
            					}
HXDLIN( 210)					if (_hx_tmp11) {
HXLINE( 212)						if (hx::IsNotNull( textEngine->_hx___cairoFont )) {
HXLINE( 214)							if (hx::IsNotEq( textEngine->_hx___font,font )) {
HXLINE( 216)								textEngine->_hx___cairoFont = null();
            							}
            						}
HXLINE( 222)						if (hx::IsNull( textEngine->_hx___cairoFont )) {
HXLINE( 224)							textEngine->_hx___font = font;
HXLINE( 225)							textEngine->_hx___cairoFont = ::lime::graphics::cairo::_CairoFTFontFace::CairoFTFontFace_Impl__obj::create(font,(int)0);
            						}
HXLINE( 229)						cairo->set_fontFace(textEngine->_hx___cairoFont);
HXLINE( 231)						size = ::Std_obj::_hx_int(group->format->size);
HXLINE( 232)						cairo->setFontSize(size);
HXLINE( 234)						Float _hx_tmp12 = (group->offsetX + scrollX);
HXDLIN( 234)						cairo->moveTo(_hx_tmp12,((group->offsetY + group->ascent) + scrollY));
HXLINE( 236)						bool usedHack = false;
HXLINE( 238)						bool _hx_tmp13;
HXDLIN( 238)						if (hx::IsNotNull( textField->_hx___filters )) {
HXLINE( 238)							_hx_tmp13 = (textField->_hx___filters->length > (int)0);
            						}
            						else {
HXLINE( 238)							_hx_tmp13 = false;
            						}
HXDLIN( 238)						if (_hx_tmp13) {
HXLINE( 242)							if (::Std_obj::is(textField->_hx___filters->__get((int)0).StaticCast<  ::openfl::filters::BitmapFilter >(),hx::ClassOf< ::openfl::filters::GlowFilter >())) {
HXLINE( 244)								cairo->textPath(::lime::text::_UTF8String::UTF8String_Impl__obj::substring(text,group->startIndex,group->endIndex));
HXLINE( 246)								 ::openfl::filters::GlowFilter glowFilter = ( ( ::openfl::filters::GlowFilter)(textField->_hx___filters->__get((int)0).StaticCast<  ::openfl::filters::BitmapFilter >()) );
HXLINE( 248)								color2 = glowFilter->get_color();
HXLINE( 249)								r2 = ((Float)hx::UShr(((int)color2 & (int)(int)16711680),(int)16) / (Float)(int)255);
HXLINE( 250)								g2 = ((Float)hx::UShr(((int)color2 & (int)(int)65280),(int)8) / (Float)(int)255);
HXLINE( 251)								b2 = ((Float)((int)color2 & (int)(int)255) / (Float)(int)255);
HXLINE( 253)								cairo->setSourceRGBA(r2,g2,b2,glowFilter->get_alpha());
HXLINE( 254)								Float _hx_tmp14 = glowFilter->get_blurX();
HXDLIN( 254)								cairo->set_lineWidth(::Math_obj::max(_hx_tmp14,glowFilter->get_blurY()));
HXLINE( 255)								cairo->strokePreserve();
HXLINE( 257)								color2 = group->format->color;
HXLINE( 258)								r2 = ((Float)hx::UShr(((int)color2 & (int)(int)16711680),(int)16) / (Float)(int)255);
HXLINE( 259)								g2 = ((Float)hx::UShr(((int)color2 & (int)(int)65280),(int)8) / (Float)(int)255);
HXLINE( 260)								b2 = ((Float)((int)color2 & (int)(int)255) / (Float)(int)255);
HXLINE( 262)								cairo->setSourceRGB(r2,g2,b2);
HXLINE( 264)								cairo->fillPreserve();
HXLINE( 265)								usedHack = true;
            							}
            						}
HXLINE( 271)						if (!(usedHack)) {
HXLINE( 279)							cairo->translate((int)0,(int)0);
HXLINE( 281)							::Array< ::Dynamic> glyphs = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 282)							Float x = (group->offsetX + scrollX);
HXLINE( 283)							Float y = ((group->offsetY + group->ascent) + scrollY);
HXLINE( 284)							int j = (int)0;
HXLINE( 286)							{
HXLINE( 286)								int _g21 = (int)0;
HXDLIN( 286)								::Array< ::Dynamic> _g3 = group->positions;
HXDLIN( 286)								while((_g21 < _g3->length)){
HXLINE( 286)									 ::lime::text::GlyphPosition position = _g3->__get(_g21).StaticCast<  ::lime::text::GlyphPosition >();
HXDLIN( 286)									_g21 = (_g21 + (int)1);
HXLINE( 288)									bool _hx_tmp15;
HXDLIN( 288)									if (hx::IsNotNull( position )) {
HXLINE( 288)										_hx_tmp15 = (position->glyph == (int)0);
            									}
            									else {
HXLINE( 288)										_hx_tmp15 = true;
            									}
HXDLIN( 288)									if (_hx_tmp15) {
HXLINE( 288)										continue;
            									}
HXLINE( 289)									int position1 = position->glyph;
HXDLIN( 289)									glyphs->push( ::lime::graphics::cairo::CairoGlyph_obj::__alloc( HX_CTX ,position1,(x + ((Float)0.5)),(y + ((Float)0.5))));
HXLINE( 290)									x = (x + position->advance->x);
            								}
            							}
HXLINE( 294)							cairo->showGlyphs(glyphs);
            						}
HXLINE( 299)						bool _hx_tmp16;
HXDLIN( 299)						if ((textField->_hx___caretIndex > (int)-1)) {
HXLINE( 299)							_hx_tmp16 = textEngine->selectable;
            						}
            						else {
HXLINE( 299)							_hx_tmp16 = false;
            						}
HXDLIN( 299)						if (_hx_tmp16) {
HXLINE( 301)							if ((textField->_hx___selectionIndex == textField->_hx___caretIndex)) {
HXLINE( 303)								bool _hx_tmp17;
HXDLIN( 303)								bool _hx_tmp18;
HXDLIN( 303)								if (textField->_hx___showCursor) {
HXLINE( 303)									_hx_tmp18 = (group->startIndex <= textField->_hx___caretIndex);
            								}
            								else {
HXLINE( 303)									_hx_tmp18 = false;
            								}
HXDLIN( 303)								if (_hx_tmp18) {
HXLINE( 303)									_hx_tmp17 = (group->endIndex >= textField->_hx___caretIndex);
            								}
            								else {
HXLINE( 303)									_hx_tmp17 = false;
            								}
HXDLIN( 303)								if (_hx_tmp17) {
HXLINE( 305)									advance = ((Float)0.0);
HXLINE( 307)									{
HXLINE( 307)										int _g31 = (int)0;
HXDLIN( 307)										int _g22 = (textField->_hx___caretIndex - group->startIndex);
HXDLIN( 307)										while((_g31 < _g22)){
HXLINE( 307)											_g31 = (_g31 + (int)1);
HXDLIN( 307)											int i1 = (_g31 - (int)1);
HXLINE( 309)											if ((group->positions->length <= i1)) {
HXLINE( 309)												goto _hx_goto_3;
            											}
HXLINE( 310)											Float advance1;
HXDLIN( 310)											bool advance2;
HXDLIN( 310)											if ((i1 >= (int)0)) {
HXLINE( 310)												advance2 = (i1 < group->positions->length);
            											}
            											else {
HXLINE( 310)												advance2 = false;
            											}
HXDLIN( 310)											if (advance2) {
HXLINE( 310)												advance1 = group->positions->__get(i1).StaticCast<  ::lime::text::GlyphPosition >()->advance->x;
            											}
            											else {
HXLINE( 310)												advance1 = (int)0;
            											}
HXDLIN( 310)											advance = (advance + advance1);
            										}
            										_hx_goto_3:;
            									}
HXLINE( 314)									Float scrollY1 = ((Float)0.0);
HXLINE( 316)									{
HXLINE( 316)										int _g32 = textField->get_scrollV();
HXDLIN( 316)										int _g23 = (group->lineIndex + (int)1);
HXDLIN( 316)										while((_g32 < _g23)){
HXLINE( 316)											_g32 = (_g32 + (int)1);
HXDLIN( 316)											int i2 = (_g32 - (int)1);
HXLINE( 318)											::Dynamic this1 = textEngine->lineHeights->data;
HXDLIN( 318)											scrollY1 = (scrollY1 + ( (Float)(::openfl::_Vector::IVector_obj::get(this1,(i2 - (int)1))) ));
            										}
            									}
HXLINE( 322)									Float _hx_tmp19 = (::Math_obj::floor((group->offsetX + advance)) + ((Float)0.5));
HXDLIN( 322)									Float _hx_tmp20 = (_hx_tmp19 - textField->get_scrollH());
HXDLIN( 322)									cairo->moveTo(_hx_tmp20,(scrollY1 + ((Float)2.5)));
HXLINE( 323)									cairo->set_lineWidth((int)1);
HXLINE( 324)									Float _hx_tmp21 = (::Math_obj::floor((group->offsetX + advance)) + ((Float)0.5));
HXDLIN( 324)									Float _hx_tmp22 = (_hx_tmp21 - textField->get_scrollH());
HXDLIN( 324)									cairo->lineTo(_hx_tmp22,((scrollY1 + ::openfl::_internal::text::TextEngine_obj::getFormatHeight(textField->get_defaultTextFormat())) - (int)1));
HXLINE( 325)									cairo->stroke();
            								}
            							}
            							else {
HXLINE( 329)								bool _hx_tmp23;
HXDLIN( 329)								bool _hx_tmp24;
HXDLIN( 329)								bool _hx_tmp25;
HXDLIN( 329)								bool _hx_tmp26;
HXDLIN( 329)								if ((group->startIndex <= textField->_hx___caretIndex)) {
HXLINE( 329)									_hx_tmp26 = (group->endIndex >= textField->_hx___caretIndex);
            								}
            								else {
HXLINE( 329)									_hx_tmp26 = false;
            								}
HXDLIN( 329)								if (!(_hx_tmp26)) {
HXLINE( 329)									if ((group->startIndex <= textField->_hx___selectionIndex)) {
HXLINE( 329)										_hx_tmp25 = (group->endIndex >= textField->_hx___selectionIndex);
            									}
            									else {
HXLINE( 329)										_hx_tmp25 = false;
            									}
            								}
            								else {
HXLINE( 329)									_hx_tmp25 = true;
            								}
HXDLIN( 329)								if (!(_hx_tmp25)) {
HXLINE( 329)									if ((group->startIndex > textField->_hx___caretIndex)) {
HXLINE( 329)										_hx_tmp24 = (group->endIndex < textField->_hx___selectionIndex);
            									}
            									else {
HXLINE( 329)										_hx_tmp24 = false;
            									}
            								}
            								else {
HXLINE( 329)									_hx_tmp24 = true;
            								}
HXDLIN( 329)								if (!(_hx_tmp24)) {
HXLINE( 329)									if ((group->startIndex > textField->_hx___selectionIndex)) {
HXLINE( 329)										_hx_tmp23 = (group->endIndex < textField->_hx___caretIndex);
            									}
            									else {
HXLINE( 329)										_hx_tmp23 = false;
            									}
            								}
            								else {
HXLINE( 329)									_hx_tmp23 = true;
            								}
HXDLIN( 329)								if (_hx_tmp23) {
HXLINE( 331)									int selectionStart = ::Std_obj::_hx_int(::Math_obj::min(textField->_hx___selectionIndex,textField->_hx___caretIndex));
HXLINE( 332)									int selectionEnd = ::Std_obj::_hx_int(::Math_obj::max(textField->_hx___selectionIndex,textField->_hx___caretIndex));
HXLINE( 334)									if ((group->startIndex > selectionStart)) {
HXLINE( 336)										selectionStart = group->startIndex;
            									}
HXLINE( 340)									if ((group->endIndex < selectionEnd)) {
HXLINE( 342)										selectionEnd = group->endIndex;
            									}
HXLINE( 346)									 ::openfl::geom::Rectangle start;
HXDLIN( 346)									 ::openfl::geom::Rectangle end;
HXLINE( 348)									start = textField->getCharBoundaries(selectionStart);
HXLINE( 350)									if ((selectionEnd >= ::lime::text::_UTF8String::UTF8String_Impl__obj::get_length(textEngine->text))) {
HXLINE( 352)										end = textField->getCharBoundaries((::lime::text::_UTF8String::UTF8String_Impl__obj::get_length(textEngine->text) - (int)1));
HXLINE( 353)										 ::openfl::geom::Rectangle end1 = end;
HXDLIN( 353)										end1->x = (end1->x + (end->width + (int)2));
            									}
            									else {
HXLINE( 357)										end = textField->getCharBoundaries(selectionEnd);
            									}
HXLINE( 361)									bool _hx_tmp27;
HXDLIN( 361)									if (hx::IsNotNull( start )) {
HXLINE( 361)										_hx_tmp27 = hx::IsNotNull( end );
            									}
            									else {
HXLINE( 361)										_hx_tmp27 = false;
            									}
HXDLIN( 361)									if (_hx_tmp27) {
HXLINE( 363)										cairo->setSourceRGB((int)0,(int)0,(int)0);
HXLINE( 364)										Float _hx_tmp28 = (scrollX + start->x);
HXDLIN( 364)										Float _hx_tmp29 = (start->y + scrollY);
HXDLIN( 364)										cairo->rectangle(_hx_tmp28,_hx_tmp29,(end->x - start->x),group->height);
HXLINE( 365)										cairo->fill();
HXLINE( 366)										cairo->setSourceRGB((int)1,(int)1,(int)1);
HXLINE( 370)										Float _hx_tmp30 = (scrollX + start->x);
HXDLIN( 370)										cairo->moveTo(_hx_tmp30,((group->offsetY + group->ascent) + scrollY));
HXLINE( 371)										cairo->showText(::lime::text::_UTF8String::UTF8String_Impl__obj::substring(text,selectionStart,selectionEnd));
            									}
            								}
            							}
            						}
            					}
            				}
            				_hx_goto_1:;
            			}
            		}
            		else {
HXLINE( 383)			bool _hx_tmp31;
HXDLIN( 383)			bool _hx_tmp32;
HXDLIN( 383)			if ((textField->_hx___caretIndex > (int)-1)) {
HXLINE( 383)				_hx_tmp32 = textEngine->selectable;
            			}
            			else {
HXLINE( 383)				_hx_tmp32 = false;
            			}
HXDLIN( 383)			if (_hx_tmp32) {
HXLINE( 383)				_hx_tmp31 = textField->_hx___showCursor;
            			}
            			else {
HXLINE( 383)				_hx_tmp31 = false;
            			}
HXDLIN( 383)			if (_hx_tmp31) {
HXLINE( 385)				int scrollX1 = -(textField->get_scrollH());
HXLINE( 386)				Float scrollY2 = ((Float)0.0);
HXLINE( 388)				{
HXLINE( 388)					int _g12 = (int)0;
HXDLIN( 388)					int _g4 = (textField->get_scrollV() - (int)1);
HXDLIN( 388)					while((_g12 < _g4)){
HXLINE( 388)						_g12 = (_g12 + (int)1);
HXDLIN( 388)						int i3 = (_g12 - (int)1);
HXLINE( 390)						scrollY2 = (scrollY2 + ( (Float)(::openfl::_Vector::IVector_obj::get(textEngine->lineHeights->data,i3)) ));
            					}
            				}
HXLINE( 394)				 ::Dynamic color3 = textField->get_defaultTextFormat()->color;
HXLINE( 395)				Float r3 = ((Float)hx::UShr(((int)color3 & (int)(int)16711680),(int)16) / (Float)(int)255);
HXLINE( 396)				Float g3 = ((Float)hx::UShr(((int)color3 & (int)(int)65280),(int)8) / (Float)(int)255);
HXLINE( 397)				Float b3 = ((Float)((int)color3 & (int)(int)255) / (Float)(int)255);
HXLINE( 399)				cairo->setSourceRGB(r3,g3,b3);
HXLINE( 401)				cairo->newPath();
HXLINE( 402)				cairo->moveTo((scrollX1 + ((Float)2.5)),(scrollY2 + ((Float)2.5)));
HXLINE( 403)				cairo->set_lineWidth((int)1);
HXLINE( 404)				cairo->lineTo((scrollX1 + ((Float)2.5)),((scrollY2 + ::openfl::_internal::text::TextEngine_obj::getFormatHeight(textField->get_defaultTextFormat())) - (int)1));
HXLINE( 405)				cairo->stroke();
HXLINE( 406)				cairo->closePath();
            			}
            		}
HXLINE( 410)		graphics->_hx___bitmap->image->dirty = true;
HXLINE( 411)		graphics->_hx___bitmap->image->version++;
HXLINE( 412)		textField->_hx___dirty = false;
HXLINE( 413)		graphics->set___dirty(false);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(CairoTextField_obj,render,(void))


CairoTextField_obj::CairoTextField_obj()
{
}

bool CairoTextField_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"render") ) { outValue = render_dyn(); return true; }
	}
	return false;
}

#if HXCPP_SCRIPTABLE
static hx::StorageInfo *CairoTextField_obj_sMemberStorageInfo = 0;
static hx::StaticInfo *CairoTextField_obj_sStaticStorageInfo = 0;
#endif

static void CairoTextField_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(CairoTextField_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void CairoTextField_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(CairoTextField_obj::__mClass,"__mClass");
};

#endif

hx::Class CairoTextField_obj::__mClass;

static ::String CairoTextField_obj_sStaticFields[] = {
	HX_HCSTRING("render","\x56","\x6b","\x29","\x05"),
	::String(null())
};

void CairoTextField_obj::__register()
{
	hx::Object *dummy = new CairoTextField_obj;
	CairoTextField_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("openfl._internal.renderer.cairo.CairoTextField","\x46","\x1d","\x84","\xa5");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &CairoTextField_obj::__GetStatic;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = CairoTextField_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(CairoTextField_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = hx::TCanCast< CairoTextField_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = CairoTextField_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = CairoTextField_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = CairoTextField_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace openfl
} // end namespace _internal
} // end namespace renderer
} // end namespace cairo
