// Generated by Haxe 3.4.4
#include <hxcpp.h>

#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_lime_utils__DataPointer_DataPointer_Impl_
#include <lime/utils/_DataPointer/DataPointer_Impl_.h>
#endif
#ifndef INCLUDED_openfl__internal_stage3D_atf_ATFReader
#include <openfl/_internal/stage3D/atf/ATFReader.h>
#endif
#ifndef INCLUDED_openfl_errors_Error
#include <openfl/errors/Error.h>
#endif
#ifndef INCLUDED_openfl_errors_IllegalOperationError
#include <openfl/errors/IllegalOperationError.h>
#endif
#ifndef INCLUDED_openfl_utils_ByteArrayData
#include <openfl/utils/ByteArrayData.h>
#endif
#ifndef INCLUDED_openfl_utils_IDataInput
#include <openfl/utils/IDataInput.h>
#endif
#ifndef INCLUDED_openfl_utils_IDataOutput
#include <openfl/utils/IDataOutput.h>
#endif
#ifndef INCLUDED_openfl_utils__ByteArray_ByteArray_Impl_
#include <openfl/utils/_ByteArray/ByteArray_Impl_.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_9e15a0b592410441_23_new,"openfl._internal.stage3D.atf.ATFReader","new",0x0b38c27e,"openfl._internal.stage3D.atf.ATFReader.new","openfl/_internal/stage3D/atf/ATFReader.hx",23,0x63888776)
HX_LOCAL_STACK_FRAME(_hx_pos_9e15a0b592410441_76_readHeader,"openfl._internal.stage3D.atf.ATFReader","readHeader",0x33e29b25,"openfl._internal.stage3D.atf.ATFReader.readHeader","openfl/_internal/stage3D/atf/ATFReader.hx",76,0x63888776)
HX_LOCAL_STACK_FRAME(_hx_pos_9e15a0b592410441_121_readTextures,"openfl._internal.stage3D.atf.ATFReader","readTextures",0x07ab1ed0,"openfl._internal.stage3D.atf.ATFReader.readTextures","openfl/_internal/stage3D/atf/ATFReader.hx",121,0x63888776)
HX_LOCAL_STACK_FRAME(_hx_pos_9e15a0b592410441_157___readUInt24,"openfl._internal.stage3D.atf.ATFReader","__readUInt24",0xb1c572f4,"openfl._internal.stage3D.atf.ATFReader.__readUInt24","openfl/_internal/stage3D/atf/ATFReader.hx",157,0x63888776)
HX_LOCAL_STACK_FRAME(_hx_pos_9e15a0b592410441_168___readUInt32,"openfl._internal.stage3D.atf.ATFReader","__readUInt32",0xb1c573d1,"openfl._internal.stage3D.atf.ATFReader.__readUInt32","openfl/_internal/stage3D/atf/ATFReader.hx",168,0x63888776)
namespace openfl{
namespace _internal{
namespace stage3D{
namespace atf{

void ATFReader_obj::__construct( ::openfl::utils::ByteArrayData data,int byteArrayOffset){
            	HX_GC_STACKFRAME(&_hx_pos_9e15a0b592410441_23_new)
HXLINE(  27)		this->version = (int)0;
HXLINE(  36)		data->position = byteArrayOffset;
HXLINE(  37)		::String signature = data->readUTFBytes((int)3);
HXLINE(  38)		data->position = byteArrayOffset;
HXLINE(  40)		if ((signature != HX_("ATF",f3,9b,31,00))) {
HXLINE(  42)			HX_STACK_DO_THROW( ::openfl::errors::IllegalOperationError_obj::__alloc( HX_CTX ,HX_("ATF signature not found",a0,f7,2f,3a)));
            		}
HXLINE(  46)		int length = (int)0;
HXLINE(  49)		if ((data->b->__get((byteArrayOffset + (int)6)) == (int)255)) {
HXLINE(  51)			this->version = data->b->__get((byteArrayOffset + (int)7));
HXLINE(  52)			data->position = (byteArrayOffset + (int)8);
HXLINE(  53)			length = this->_hx___readUInt32(data);
            		}
            		else {
HXLINE(  58)			this->version = (int)0;
HXLINE(  59)			data->position = (byteArrayOffset + (int)3);
HXLINE(  60)			length = this->_hx___readUInt24(data);
            		}
HXLINE(  65)		int _hx_tmp = (byteArrayOffset + length);
HXDLIN(  65)		if ((_hx_tmp > ::openfl::utils::_ByteArray::ByteArray_Impl__obj::get_length(data))) {
HXLINE(  67)			HX_STACK_DO_THROW( ::openfl::errors::IllegalOperationError_obj::__alloc( HX_CTX ,HX_("ATF length exceeds byte array length",d7,29,45,0f)));
            		}
HXLINE(  71)		this->data = data;
            	}

Dynamic ATFReader_obj::__CreateEmpty() { return new ATFReader_obj; }

void *ATFReader_obj::_hx_vtable = 0;

Dynamic ATFReader_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< ATFReader_obj > _hx_result = new ATFReader_obj();
	_hx_result->__construct(inArgs[0],inArgs[1]);
	return _hx_result;
}

bool ATFReader_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x687242c6;
}

bool ATFReader_obj::readHeader(int _hx___width,int _hx___height,bool cubeMap){
            	HX_GC_STACKFRAME(&_hx_pos_9e15a0b592410441_76_readHeader)
HXLINE(  78)		int tdata = this->data->readUnsignedByte();
HXLINE(  79)		int type = ((int)tdata >> (int)(int)7);
HXLINE(  81)		bool _hx_tmp;
HXDLIN(  81)		if (!(cubeMap)) {
HXLINE(  81)			_hx_tmp = (type != (int)0);
            		}
            		else {
HXLINE(  81)			_hx_tmp = false;
            		}
HXDLIN(  81)		if (_hx_tmp) {
HXLINE(  83)			HX_STACK_DO_THROW( ::openfl::errors::IllegalOperationError_obj::__alloc( HX_CTX ,HX_("ATF Cube map not expected",a7,74,ca,c8)));
            		}
HXLINE(  87)		bool _hx_tmp1;
HXDLIN(  87)		if (cubeMap) {
HXLINE(  87)			_hx_tmp1 = (type != (int)1);
            		}
            		else {
HXLINE(  87)			_hx_tmp1 = false;
            		}
HXDLIN(  87)		if (_hx_tmp1) {
HXLINE(  89)			HX_STACK_DO_THROW( ::openfl::errors::IllegalOperationError_obj::__alloc( HX_CTX ,HX_("ATF Cube map expected",fa,fe,ed,52)));
            		}
HXLINE(  93)		this->cubeMap = cubeMap;
HXLINE(  95)		int atfFormat = ((int)tdata & (int)(int)127);
HXLINE(  98)		bool _hx_tmp2;
HXDLIN(  98)		if ((atfFormat != (int)3)) {
HXLINE(  98)			_hx_tmp2 = (atfFormat != (int)5);
            		}
            		else {
HXLINE(  98)			_hx_tmp2 = false;
            		}
HXDLIN(  98)		if (_hx_tmp2) {
HXLINE( 100)			HX_STACK_DO_THROW( ::openfl::errors::IllegalOperationError_obj::__alloc( HX_CTX ,HX_("Only ATF block compressed textures without JPEG-XR+LZMA are supported",25,8c,50,6a)));
            		}
HXLINE( 105)		this->width = ((int)(int)1 << (int)this->data->readUnsignedByte());
HXLINE( 106)		this->height = ((int)(int)1 << (int)this->data->readUnsignedByte());
HXLINE( 108)		bool _hx_tmp3;
HXDLIN( 108)		if ((this->width == _hx___width)) {
HXLINE( 108)			_hx_tmp3 = (this->height != _hx___height);
            		}
            		else {
HXLINE( 108)			_hx_tmp3 = true;
            		}
HXDLIN( 108)		if (_hx_tmp3) {
HXLINE( 110)			HX_STACK_DO_THROW( ::openfl::errors::IllegalOperationError_obj::__alloc( HX_CTX ,HX_("ATF width and height dont match",3f,49,15,70)));
            		}
HXLINE( 114)		this->mipCount = this->data->readUnsignedByte();
HXLINE( 116)		return (atfFormat == (int)3);
            	}


HX_DEFINE_DYNAMIC_FUNC3(ATFReader_obj,readHeader,return )

void ATFReader_obj::readTextures( ::Dynamic uploadCallback){
            	HX_GC_STACKFRAME(&_hx_pos_9e15a0b592410441_121_readTextures)
HXLINE( 125)		int gpuFormats;
HXDLIN( 125)		if ((this->version < (int)3)) {
HXLINE( 125)			gpuFormats = (int)3;
            		}
            		else {
HXLINE( 125)			gpuFormats = (int)4;
            		}
HXLINE( 126)		int sideCount;
HXDLIN( 126)		if (this->cubeMap) {
HXLINE( 126)			sideCount = (int)6;
            		}
            		else {
HXLINE( 126)			sideCount = (int)1;
            		}
HXLINE( 128)		{
HXLINE( 128)			int _g1 = (int)0;
HXDLIN( 128)			int _g = sideCount;
HXDLIN( 128)			while((_g1 < _g)){
HXLINE( 128)				_g1 = (_g1 + (int)1);
HXDLIN( 128)				int side = (_g1 - (int)1);
HXLINE( 129)				{
HXLINE( 129)					int _g3 = (int)0;
HXDLIN( 129)					int _g2 = this->mipCount;
HXDLIN( 129)					while((_g3 < _g2)){
HXLINE( 129)						_g3 = (_g3 + (int)1);
HXDLIN( 129)						int level = (_g3 - (int)1);
HXLINE( 131)						{
HXLINE( 131)							int _g5 = (int)0;
HXDLIN( 131)							int _g4 = gpuFormats;
HXDLIN( 131)							while((_g5 < _g4)){
HXLINE( 131)								_g5 = (_g5 + (int)1);
HXDLIN( 131)								int gpuFormat = (_g5 - (int)1);
HXLINE( 133)								int blockLength;
HXDLIN( 133)								if ((this->version == (int)0)) {
HXLINE( 133)									blockLength = this->_hx___readUInt24(this->data);
            								}
            								else {
HXLINE( 133)									blockLength = this->_hx___readUInt32(this->data);
            								}
HXLINE( 135)								int a = (this->data->position + blockLength);
HXDLIN( 135)								int b = ::openfl::utils::_ByteArray::ByteArray_Impl__obj::get_length(this->data);
HXDLIN( 135)								bool aNeg = (a < (int)0);
HXDLIN( 135)								bool bNeg = (b < (int)0);
HXDLIN( 135)								bool _hx_tmp;
HXDLIN( 135)								if ((aNeg != bNeg)) {
HXLINE( 135)									_hx_tmp = aNeg;
            								}
            								else {
HXLINE( 135)									_hx_tmp = (a > b);
            								}
HXDLIN( 135)								if (_hx_tmp) {
HXLINE( 137)									HX_STACK_DO_THROW( ::openfl::errors::IllegalOperationError_obj::__alloc( HX_CTX ,HX_("Block length exceeds ATF file length",15,23,c0,24)));
            								}
HXLINE( 141)								bool aNeg1 = (blockLength < (int)0);
HXDLIN( 141)								bool bNeg1 = ((int)0 < (int)0);
HXDLIN( 141)								bool _hx_tmp1;
HXDLIN( 141)								if ((aNeg1 != bNeg1)) {
HXLINE( 141)									_hx_tmp1 = aNeg1;
            								}
            								else {
HXLINE( 141)									_hx_tmp1 = (blockLength > (int)0);
            								}
HXDLIN( 141)								if (_hx_tmp1) {
HXLINE( 143)									 ::haxe::io::Bytes bytes = ::haxe::io::Bytes_obj::alloc(blockLength);
HXLINE( 144)									 ::openfl::utils::ByteArrayData _hx_tmp2 = this->data;
HXDLIN( 144)									_hx_tmp2->readBytes(::openfl::utils::_ByteArray::ByteArray_Impl__obj::fromArrayBuffer(bytes),(int)0,blockLength);
HXLINE( 146)									int _hx_tmp3 = ((int)this->width >> (int)level);
HXDLIN( 146)									int _hx_tmp4 = ((int)this->height >> (int)level);
HXDLIN( 146)									uploadCallback(side,level,gpuFormat,_hx_tmp3,_hx_tmp4,blockLength,::lime::utils::_DataPointer::DataPointer_Impl__obj::fromArrayBuffer(bytes));
            								}
            							}
            						}
            					}
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(ATFReader_obj,readTextures,(void))

int ATFReader_obj::_hx___readUInt24( ::openfl::utils::ByteArrayData data){
            	HX_STACKFRAME(&_hx_pos_9e15a0b592410441_157___readUInt24)
HXLINE( 159)		int value = ((int)data->readUnsignedByte() << (int)(int)16);
HXLINE( 161)		value = ((int)value | (int)((int)data->readUnsignedByte() << (int)(int)8));
HXLINE( 162)		value = ((int)value | (int)data->readUnsignedByte());
HXLINE( 163)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(ATFReader_obj,_hx___readUInt24,return )

int ATFReader_obj::_hx___readUInt32( ::openfl::utils::ByteArrayData data){
            	HX_STACKFRAME(&_hx_pos_9e15a0b592410441_168___readUInt32)
HXLINE( 170)		int value = ((int)data->readUnsignedByte() << (int)(int)24);
HXLINE( 172)		value = ((int)value | (int)((int)data->readUnsignedByte() << (int)(int)16));
HXLINE( 173)		value = ((int)value | (int)((int)data->readUnsignedByte() << (int)(int)8));
HXLINE( 174)		value = ((int)value | (int)data->readUnsignedByte());
HXLINE( 175)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(ATFReader_obj,_hx___readUInt32,return )


hx::ObjectPtr< ATFReader_obj > ATFReader_obj::__new( ::openfl::utils::ByteArrayData data,int byteArrayOffset) {
	hx::ObjectPtr< ATFReader_obj > __this = new ATFReader_obj();
	__this->__construct(data,byteArrayOffset);
	return __this;
}

hx::ObjectPtr< ATFReader_obj > ATFReader_obj::__alloc(hx::Ctx *_hx_ctx, ::openfl::utils::ByteArrayData data,int byteArrayOffset) {
	ATFReader_obj *__this = (ATFReader_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(ATFReader_obj), true, "openfl._internal.stage3D.atf.ATFReader"));
	*(void **)__this = ATFReader_obj::_hx_vtable;
	__this->__construct(data,byteArrayOffset);
	return __this;
}

ATFReader_obj::ATFReader_obj()
{
}

void ATFReader_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(ATFReader);
	HX_MARK_MEMBER_NAME(data,"data");
	HX_MARK_MEMBER_NAME(version,"version");
	HX_MARK_MEMBER_NAME(cubeMap,"cubeMap");
	HX_MARK_MEMBER_NAME(width,"width");
	HX_MARK_MEMBER_NAME(height,"height");
	HX_MARK_MEMBER_NAME(mipCount,"mipCount");
	HX_MARK_END_CLASS();
}

void ATFReader_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(data,"data");
	HX_VISIT_MEMBER_NAME(version,"version");
	HX_VISIT_MEMBER_NAME(cubeMap,"cubeMap");
	HX_VISIT_MEMBER_NAME(width,"width");
	HX_VISIT_MEMBER_NAME(height,"height");
	HX_VISIT_MEMBER_NAME(mipCount,"mipCount");
}

hx::Val ATFReader_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"data") ) { return hx::Val( data ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"width") ) { return hx::Val( width ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"height") ) { return hx::Val( height ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"version") ) { return hx::Val( version ); }
		if (HX_FIELD_EQ(inName,"cubeMap") ) { return hx::Val( cubeMap ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"mipCount") ) { return hx::Val( mipCount ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"readHeader") ) { return hx::Val( readHeader_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"readTextures") ) { return hx::Val( readTextures_dyn() ); }
		if (HX_FIELD_EQ(inName,"__readUInt24") ) { return hx::Val( _hx___readUInt24_dyn() ); }
		if (HX_FIELD_EQ(inName,"__readUInt32") ) { return hx::Val( _hx___readUInt32_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val ATFReader_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"data") ) { data=inValue.Cast<  ::openfl::utils::ByteArrayData >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"width") ) { width=inValue.Cast< int >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"height") ) { height=inValue.Cast< int >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"version") ) { version=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"cubeMap") ) { cubeMap=inValue.Cast< bool >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"mipCount") ) { mipCount=inValue.Cast< int >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void ATFReader_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("data","\x2a","\x56","\x63","\x42"));
	outFields->push(HX_HCSTRING("version","\x18","\xe7","\xf1","\x7c"));
	outFields->push(HX_HCSTRING("cubeMap","\xa7","\x4c","\xd0","\x8c"));
	outFields->push(HX_HCSTRING("width","\x06","\xb6","\x62","\xca"));
	outFields->push(HX_HCSTRING("height","\xe7","\x07","\x4c","\x02"));
	outFields->push(HX_HCSTRING("mipCount","\x9b","\x6a","\x51","\x0e"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo ATFReader_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*::openfl::utils::ByteArrayData*/ ,(int)offsetof(ATFReader_obj,data),HX_HCSTRING("data","\x2a","\x56","\x63","\x42")},
	{hx::fsInt,(int)offsetof(ATFReader_obj,version),HX_HCSTRING("version","\x18","\xe7","\xf1","\x7c")},
	{hx::fsBool,(int)offsetof(ATFReader_obj,cubeMap),HX_HCSTRING("cubeMap","\xa7","\x4c","\xd0","\x8c")},
	{hx::fsInt,(int)offsetof(ATFReader_obj,width),HX_HCSTRING("width","\x06","\xb6","\x62","\xca")},
	{hx::fsInt,(int)offsetof(ATFReader_obj,height),HX_HCSTRING("height","\xe7","\x07","\x4c","\x02")},
	{hx::fsInt,(int)offsetof(ATFReader_obj,mipCount),HX_HCSTRING("mipCount","\x9b","\x6a","\x51","\x0e")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *ATFReader_obj_sStaticStorageInfo = 0;
#endif

static ::String ATFReader_obj_sMemberFields[] = {
	HX_HCSTRING("data","\x2a","\x56","\x63","\x42"),
	HX_HCSTRING("version","\x18","\xe7","\xf1","\x7c"),
	HX_HCSTRING("cubeMap","\xa7","\x4c","\xd0","\x8c"),
	HX_HCSTRING("width","\x06","\xb6","\x62","\xca"),
	HX_HCSTRING("height","\xe7","\x07","\x4c","\x02"),
	HX_HCSTRING("mipCount","\x9b","\x6a","\x51","\x0e"),
	HX_HCSTRING("readHeader","\x83","\xed","\x7b","\xf6"),
	HX_HCSTRING("readTextures","\xae","\x44","\x04","\xa1"),
	HX_HCSTRING("__readUInt24","\xd2","\x98","\x1e","\x4b"),
	HX_HCSTRING("__readUInt32","\xaf","\x99","\x1e","\x4b"),
	::String(null()) };

static void ATFReader_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(ATFReader_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void ATFReader_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(ATFReader_obj::__mClass,"__mClass");
};

#endif

hx::Class ATFReader_obj::__mClass;

void ATFReader_obj::__register()
{
	hx::Object *dummy = new ATFReader_obj;
	ATFReader_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("openfl._internal.stage3D.atf.ATFReader","\x8c","\x6b","\x52","\x5f");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = ATFReader_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(ATFReader_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< ATFReader_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = ATFReader_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = ATFReader_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = ATFReader_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace openfl
} // end namespace _internal
} // end namespace stage3D
} // end namespace atf
