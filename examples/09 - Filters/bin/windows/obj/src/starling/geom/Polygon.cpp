// Generated by Haxe 3.4.4
#include <hxcpp.h>

#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_Type
#include <Type.h>
#endif
#ifndef INCLUDED_openfl__Vector_AbstractVector
#include <openfl/_Vector/AbstractVector.h>
#endif
#ifndef INCLUDED_openfl__Vector_FloatVector
#include <openfl/_Vector/FloatVector.h>
#endif
#ifndef INCLUDED_openfl__Vector_IVector
#include <openfl/_Vector/IVector.h>
#endif
#ifndef INCLUDED_openfl__Vector_IntVector
#include <openfl/_Vector/IntVector.h>
#endif
#ifndef INCLUDED_openfl_errors_ArgumentError
#include <openfl/errors/ArgumentError.h>
#endif
#ifndef INCLUDED_openfl_errors_Error
#include <openfl/errors/Error.h>
#endif
#ifndef INCLUDED_openfl_errors_RangeError
#include <openfl/errors/RangeError.h>
#endif
#ifndef INCLUDED_openfl_geom_Point
#include <openfl/geom/Point.h>
#endif
#ifndef INCLUDED_starling_geom_Ellipse
#include <starling/geom/Ellipse.h>
#endif
#ifndef INCLUDED_starling_geom_ImmutablePolygon
#include <starling/geom/ImmutablePolygon.h>
#endif
#ifndef INCLUDED_starling_geom_Polygon
#include <starling/geom/Polygon.h>
#endif
#ifndef INCLUDED_starling_geom_Rectangle
#include <starling/geom/Rectangle.h>
#endif
#ifndef INCLUDED_starling_rendering_IndexData
#include <starling/rendering/IndexData.h>
#endif
#ifndef INCLUDED_starling_rendering_VertexData
#include <starling/rendering/VertexData.h>
#endif
#ifndef INCLUDED_starling_utils_MathUtil
#include <starling/utils/MathUtil.h>
#endif
#ifndef INCLUDED_starling_utils_Pool
#include <starling/utils/Pool.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_e3b2ec681bf6a970_43_new,"starling.geom.Polygon","new",0x3b5e6a00,"starling.geom.Polygon.new","starling/geom/Polygon.hx",43,0x416f69d0)
HX_LOCAL_STACK_FRAME(_hx_pos_e3b2ec681bf6a970_50_clone,"starling.geom.Polygon","clone",0x4e7f54fd,"starling.geom.Polygon.clone","starling/geom/Polygon.hx",50,0x416f69d0)
HX_LOCAL_STACK_FRAME(_hx_pos_e3b2ec681bf6a970_63_reverse,"starling.geom.Polygon","reverse",0x11e422c2,"starling.geom.Polygon.reverse","starling/geom/Polygon.hx",63,0x416f69d0)
HX_LOCAL_STACK_FRAME(_hx_pos_e3b2ec681bf6a970_85_addVertices,"starling.geom.Polygon","addVertices",0x0f1f30da,"starling.geom.Polygon.addVertices","starling/geom/Polygon.hx",85,0x416f69d0)
HX_LOCAL_STACK_FRAME(_hx_pos_e3b2ec681bf6a970_112_setVertex,"starling.geom.Polygon","setVertex",0x70dce246,"starling.geom.Polygon.setVertex","starling/geom/Polygon.hx",112,0x416f69d0)
HX_LOCAL_STACK_FRAME(_hx_pos_e3b2ec681bf6a970_123_getVertex,"starling.geom.Polygon","getVertex",0x8d8bf63a,"starling.geom.Polygon.getVertex","starling/geom/Polygon.hx",123,0x416f69d0)
HX_LOCAL_STACK_FRAME(_hx_pos_e3b2ec681bf6a970_134_contains,"starling.geom.Polygon","contains",0x407fdc7f,"starling.geom.Polygon.contains","starling/geom/Polygon.hx",134,0x416f69d0)
HX_LOCAL_STACK_FRAME(_hx_pos_e3b2ec681bf6a970_160_containsPoint,"starling.geom.Polygon","containsPoint",0x37929b51,"starling.geom.Polygon.containsPoint","starling/geom/Polygon.hx",160,0x416f69d0)
HX_LOCAL_STACK_FRAME(_hx_pos_e3b2ec681bf6a970_170_triangulate,"starling.geom.Polygon","triangulate",0x5d4a9ecc,"starling.geom.Polygon.triangulate","starling/geom/Polygon.hx",170,0x416f69d0)
HX_LOCAL_STACK_FRAME(_hx_pos_e3b2ec681bf6a970_257_copyToVertexData,"starling.geom.Polygon","copyToVertexData",0x6b7936be,"starling.geom.Polygon.copyToVertexData","starling/geom/Polygon.hx",257,0x416f69d0)
HX_LOCAL_STACK_FRAME(_hx_pos_e3b2ec681bf6a970_270_toString,"starling.geom.Polygon","toString",0x4c73530c,"starling.geom.Polygon.toString","starling/geom/Polygon.hx",270,0x416f69d0)
HX_LOCAL_STACK_FRAME(_hx_pos_e3b2ec681bf6a970_349_get_isSimple,"starling.geom.Polygon","get_isSimple",0x89e78625,"starling.geom.Polygon.get_isSimple","starling/geom/Polygon.hx",349,0x416f69d0)
HX_LOCAL_STACK_FRAME(_hx_pos_e3b2ec681bf6a970_384_get_isConvex,"starling.geom.Polygon","get_isConvex",0x9946f95a,"starling.geom.Polygon.get_isConvex","starling/geom/Polygon.hx",384,0x416f69d0)
HX_LOCAL_STACK_FRAME(_hx_pos_e3b2ec681bf6a970_409_get_area,"starling.geom.Polygon","get_area",0xd433c976,"starling.geom.Polygon.get_area","starling/geom/Polygon.hx",409,0x416f69d0)
HX_LOCAL_STACK_FRAME(_hx_pos_e3b2ec681bf6a970_433_get_numVertices,"starling.geom.Polygon","get_numVertices",0x5c685196,"starling.geom.Polygon.get_numVertices","starling/geom/Polygon.hx",433,0x416f69d0)
HX_LOCAL_STACK_FRAME(_hx_pos_e3b2ec681bf6a970_437_set_numVertices,"starling.geom.Polygon","set_numVertices",0x5833cea2,"starling.geom.Polygon.set_numVertices","starling/geom/Polygon.hx",437,0x416f69d0)
HX_LOCAL_STACK_FRAME(_hx_pos_e3b2ec681bf6a970_452_get_numTriangles,"starling.geom.Polygon","get_numTriangles",0x952e086e,"starling.geom.Polygon.get_numTriangles","starling/geom/Polygon.hx",452,0x416f69d0)
HX_LOCAL_STACK_FRAME(_hx_pos_e3b2ec681bf6a970_292_createEllipse,"starling.geom.Polygon","createEllipse",0x986ffae2,"starling.geom.Polygon.createEllipse","starling/geom/Polygon.hx",292,0x416f69d0)
HX_LOCAL_STACK_FRAME(_hx_pos_e3b2ec681bf6a970_298_createCircle,"starling.geom.Polygon","createCircle",0x3c47e48c,"starling.geom.Polygon.createCircle","starling/geom/Polygon.hx",298,0x416f69d0)
HX_LOCAL_STACK_FRAME(_hx_pos_e3b2ec681bf6a970_305_createRectangle,"starling.geom.Polygon","createRectangle",0xffcc1733,"starling.geom.Polygon.createRectangle","starling/geom/Polygon.hx",305,0x416f69d0)
HX_LOCAL_STACK_FRAME(_hx_pos_e3b2ec681bf6a970_316_isConvexTriangle,"starling.geom.Polygon","isConvexTriangle",0x08434939,"starling.geom.Polygon.isConvexTriangle","starling/geom/Polygon.hx",316,0x416f69d0)
HX_LOCAL_STACK_FRAME(_hx_pos_e3b2ec681bf6a970_322_areVectorsIntersecting,"starling.geom.Polygon","areVectorsIntersecting",0x6857483f,"starling.geom.Polygon.areVectorsIntersecting","starling/geom/Polygon.hx",322,0x416f69d0)
HX_LOCAL_STACK_FRAME(_hx_pos_e3b2ec681bf6a970_36_boot,"starling.geom.Polygon","boot",0xaf575692,"starling.geom.Polygon.boot","starling/geom/Polygon.hx",36,0x416f69d0)
namespace starling{
namespace geom{

void Polygon_obj::__construct(::cpp::VirtualArray vertices){
            	HX_GC_STACKFRAME(&_hx_pos_e3b2ec681bf6a970_43_new)
HXLINE(  44)		int length = null();
HXDLIN(  44)		bool fixed = null();
HXDLIN(  44)		this->_hx___coords =  ::openfl::_Vector::AbstractVector_obj::__alloc( HX_CTX , ::openfl::_Vector::FloatVector_obj::__alloc( HX_CTX ,length,fixed,null()),null());
HXLINE(  45)		this->addVertices(vertices);
            	}

Dynamic Polygon_obj::__CreateEmpty() { return new Polygon_obj; }

void *Polygon_obj::_hx_vtable = 0;

Dynamic Polygon_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Polygon_obj > _hx_result = new Polygon_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

bool Polygon_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x481a82d6;
}

 ::starling::geom::Polygon Polygon_obj::clone(){
            	HX_GC_STACKFRAME(&_hx_pos_e3b2ec681bf6a970_50_clone)
HXLINE(  51)		 ::starling::geom::Polygon clone =  ::starling::geom::Polygon_obj::__alloc( HX_CTX ,null());
HXLINE(  52)		int numCoords = ::openfl::_Vector::IVector_obj::get_length(this->_hx___coords->data);
HXLINE(  54)		{
HXLINE(  54)			int _g1 = (int)0;
HXDLIN(  54)			int _g = numCoords;
HXDLIN(  54)			while((_g1 < _g)){
HXLINE(  54)				_g1 = (_g1 + (int)1);
HXDLIN(  54)				int i = (_g1 - (int)1);
HXLINE(  55)				{
HXLINE(  55)					 ::openfl::_Vector::AbstractVector this1 = clone->_hx___coords;
HXDLIN(  55)					Float value = ( (Float)(::openfl::_Vector::IVector_obj::get(this->_hx___coords->data,i)) );
HXDLIN(  55)					::openfl::_Vector::IVector_obj::set(this1->data,i,value);
            				}
            			}
            		}
HXLINE(  57)		return clone;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Polygon_obj,clone,return )

void Polygon_obj::reverse(){
            	HX_STACKFRAME(&_hx_pos_e3b2ec681bf6a970_63_reverse)
HXLINE(  64)		int numCoords = ::openfl::_Vector::IVector_obj::get_length(this->_hx___coords->data);
HXLINE(  65)		int numVertices = ::Std_obj::_hx_int(((Float)numCoords / (Float)(int)2));
HXLINE(  66)		Float tmp;
HXLINE(  68)		int i = (int)0;
HXLINE(  69)		while((i < numVertices)){
HXLINE(  71)			tmp = ( (Float)(::openfl::_Vector::IVector_obj::get(this->_hx___coords->data,i)) );
HXLINE(  72)			{
HXLINE(  72)				 ::openfl::_Vector::AbstractVector this1 = this->_hx___coords;
HXDLIN(  72)				::Dynamic this2 = this->_hx___coords->data;
HXDLIN(  72)				Float value = ( (Float)(::openfl::_Vector::IVector_obj::get(this2,((numCoords - i) - (int)2))) );
HXDLIN(  72)				::openfl::_Vector::IVector_obj::set(this1->data,i,value);
            			}
HXLINE(  73)			{
HXLINE(  73)				::Dynamic this3 = this->_hx___coords->data;
HXDLIN(  73)				::openfl::_Vector::IVector_obj::set(this3,((numCoords - i) - (int)2),tmp);
            			}
HXLINE(  75)			::Dynamic this4 = this->_hx___coords->data;
HXDLIN(  75)			tmp = ( (Float)(::openfl::_Vector::IVector_obj::get(this4,(i + (int)1))) );
HXLINE(  76)			{
HXLINE(  76)				 ::openfl::_Vector::AbstractVector this5 = this->_hx___coords;
HXDLIN(  76)				::Dynamic this6 = this->_hx___coords->data;
HXDLIN(  76)				Float value1 = ( (Float)(::openfl::_Vector::IVector_obj::get(this6,((numCoords - i) - (int)1))) );
HXDLIN(  76)				::Dynamic this7 = this5->data;
HXDLIN(  76)				::openfl::_Vector::IVector_obj::set(this7,(i + (int)1),value1);
            			}
HXLINE(  77)			{
HXLINE(  77)				::Dynamic this8 = this->_hx___coords->data;
HXDLIN(  77)				::openfl::_Vector::IVector_obj::set(this8,((numCoords - i) - (int)1),tmp);
            			}
HXLINE(  78)			i = (i + (int)2);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Polygon_obj,reverse,(void))

void Polygon_obj::addVertices(::cpp::VirtualArray args){
            	HX_GC_STACKFRAME(&_hx_pos_e3b2ec681bf6a970_85_addVertices)
HXLINE(  86)		int i;
HXLINE(  87)		int numArgs = args->get_length();
HXLINE(  88)		int numCoords = ::openfl::_Vector::IVector_obj::get_length(this->_hx___coords->data);
HXLINE(  90)		if ((numArgs > (int)0)) {
HXLINE(  92)			if (::Std_obj::is(args->__get((int)0),hx::ClassOf< ::openfl::geom::Point >())) {
HXLINE(  94)				int _g1 = (int)0;
HXDLIN(  94)				int _g = numArgs;
HXDLIN(  94)				while((_g1 < _g)){
HXLINE(  94)					_g1 = (_g1 + (int)1);
HXDLIN(  94)					int i1 = (_g1 - (int)1);
HXLINE(  96)					{
HXLINE(  96)						::Dynamic this1 = this->_hx___coords->data;
HXDLIN(  96)						::openfl::_Vector::IVector_obj::set(this1,(numCoords + (i1 * (int)2)),hx::TCast<  ::openfl::geom::Point >::cast(args->__get(i1))->x);
            					}
HXLINE(  97)					{
HXLINE(  97)						::Dynamic this2 = this->_hx___coords->data;
HXDLIN(  97)						::openfl::_Vector::IVector_obj::set(this2,((numCoords + (i1 * (int)2)) + (int)1),hx::TCast<  ::openfl::geom::Point >::cast(args->__get(i1))->y);
            					}
            				}
            			}
            			else {
HXLINE( 100)				if (::Std_obj::is(args->__get((int)0),hx::ClassOf< ::Float >())) {
HXLINE( 102)					int _g11 = (int)0;
HXDLIN( 102)					int _g2 = numArgs;
HXDLIN( 102)					while((_g11 < _g2)){
HXLINE( 102)						_g11 = (_g11 + (int)1);
HXDLIN( 102)						int i2 = (_g11 - (int)1);
HXLINE( 103)						{
HXLINE( 103)							::Dynamic this3 = this->_hx___coords->data;
HXDLIN( 103)							::openfl::_Vector::IVector_obj::set(this3,(numCoords + i2),( (Float)(args->__get(i2)) ));
            						}
            					}
            				}
            				else {
HXLINE( 105)					HX_STACK_DO_THROW( ::openfl::errors::ArgumentError_obj::__alloc( HX_CTX ,(HX_("Invalid type: ",09,b6,ae,24) + ::Type_obj::getClassName(::Type_obj::getClass(args->__get((int)0))))));
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(Polygon_obj,addVertices,(void))

void Polygon_obj::setVertex(int index,Float x,Float y){
            	HX_GC_STACKFRAME(&_hx_pos_e3b2ec681bf6a970_112_setVertex)
HXDLIN( 112)		bool _hx_tmp;
HXDLIN( 112)		if ((index >= (int)0)) {
HXDLIN( 112)			_hx_tmp = (index <= this->get_numVertices());
            		}
            		else {
HXDLIN( 112)			_hx_tmp = false;
            		}
HXDLIN( 112)		if (_hx_tmp) {
HXLINE( 114)			{
HXLINE( 114)				::Dynamic this1 = this->_hx___coords->data;
HXDLIN( 114)				::openfl::_Vector::IVector_obj::set(this1,(index * (int)2),x);
            			}
HXLINE( 115)			{
HXLINE( 115)				::Dynamic this2 = this->_hx___coords->data;
HXDLIN( 115)				::openfl::_Vector::IVector_obj::set(this2,((index * (int)2) + (int)1),y);
            			}
            		}
            		else {
HXLINE( 117)			HX_STACK_DO_THROW( ::openfl::errors::RangeError_obj::__alloc( HX_CTX ,(HX_("Invalid index: ",ef,ab,37,dc) + index)));
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC3(Polygon_obj,setVertex,(void))

 ::openfl::geom::Point Polygon_obj::getVertex(int index, ::openfl::geom::Point out){
            	HX_GC_STACKFRAME(&_hx_pos_e3b2ec681bf6a970_123_getVertex)
HXDLIN( 123)		bool _hx_tmp;
HXDLIN( 123)		if ((index >= (int)0)) {
HXDLIN( 123)			_hx_tmp = (index < this->get_numVertices());
            		}
            		else {
HXDLIN( 123)			_hx_tmp = false;
            		}
HXDLIN( 123)		if (_hx_tmp) {
HXLINE( 125)			if (hx::IsNull( out )) {
HXLINE( 125)				out =  ::openfl::geom::Point_obj::__alloc( HX_CTX ,null(),null());
            			}
            			else {
HXLINE( 125)				out = out;
            			}
HXLINE( 126)			::Dynamic this1 = this->_hx___coords->data;
HXDLIN( 126)			Float _hx_tmp1 = ( (Float)(::openfl::_Vector::IVector_obj::get(this1,(index * (int)2))) );
HXDLIN( 126)			::Dynamic this2 = this->_hx___coords->data;
HXDLIN( 126)			out->setTo(_hx_tmp1,( (Float)(::openfl::_Vector::IVector_obj::get(this2,((index * (int)2) + (int)1))) ));
HXLINE( 127)			return out;
            		}
            		else {
HXLINE( 129)			HX_STACK_DO_THROW( ::openfl::errors::RangeError_obj::__alloc( HX_CTX ,(HX_("Invalid index: ",ef,ab,37,dc) + index)));
            		}
HXLINE( 123)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC2(Polygon_obj,getVertex,return )

bool Polygon_obj::contains(Float x,Float y){
            	HX_STACKFRAME(&_hx_pos_e3b2ec681bf6a970_134_contains)
HXLINE( 138)		int i;
HXDLIN( 138)		int j = (this->get_numVertices() - (int)1);
HXLINE( 139)		int oddNodes = (int)0;
HXLINE( 141)		{
HXLINE( 141)			int _g1 = (int)0;
HXDLIN( 141)			int _g = this->get_numVertices();
HXDLIN( 141)			while((_g1 < _g)){
HXLINE( 141)				_g1 = (_g1 + (int)1);
HXDLIN( 141)				int i1 = (_g1 - (int)1);
HXLINE( 143)				::Dynamic this1 = this->_hx___coords->data;
HXDLIN( 143)				Float ix = ( (Float)(::openfl::_Vector::IVector_obj::get(this1,(i1 * (int)2))) );
HXLINE( 144)				::Dynamic this2 = this->_hx___coords->data;
HXDLIN( 144)				Float iy = ( (Float)(::openfl::_Vector::IVector_obj::get(this2,((i1 * (int)2) + (int)1))) );
HXLINE( 145)				::Dynamic this3 = this->_hx___coords->data;
HXDLIN( 145)				Float jx = ( (Float)(::openfl::_Vector::IVector_obj::get(this3,(j * (int)2))) );
HXLINE( 146)				::Dynamic this4 = this->_hx___coords->data;
HXDLIN( 146)				Float jy = ( (Float)(::openfl::_Vector::IVector_obj::get(this4,((j * (int)2) + (int)1))) );
HXLINE( 148)				bool _hx_tmp;
HXDLIN( 148)				bool _hx_tmp1;
HXDLIN( 148)				bool _hx_tmp2;
HXDLIN( 148)				if ((iy < y)) {
HXLINE( 148)					_hx_tmp2 = (jy >= y);
            				}
            				else {
HXLINE( 148)					_hx_tmp2 = false;
            				}
HXDLIN( 148)				if (!(_hx_tmp2)) {
HXLINE( 148)					if ((jy < y)) {
HXLINE( 148)						_hx_tmp1 = (iy >= y);
            					}
            					else {
HXLINE( 148)						_hx_tmp1 = false;
            					}
            				}
            				else {
HXLINE( 148)					_hx_tmp1 = true;
            				}
HXDLIN( 148)				if (_hx_tmp1) {
HXLINE( 148)					if (!((ix <= x))) {
HXLINE( 148)						_hx_tmp = (jx <= x);
            					}
            					else {
HXLINE( 148)						_hx_tmp = true;
            					}
            				}
            				else {
HXLINE( 148)					_hx_tmp = false;
            				}
HXDLIN( 148)				if (_hx_tmp) {
HXLINE( 149)					int oddNodes1;
HXDLIN( 149)					if (((ix + (((Float)(y - iy) / (Float)(jy - iy)) * (jx - ix))) < x)) {
HXLINE( 149)						oddNodes1 = (int)1;
            					}
            					else {
HXLINE( 149)						oddNodes1 = (int)0;
            					}
HXDLIN( 149)					oddNodes = ((int)oddNodes ^ (int)oddNodes1);
            				}
HXLINE( 151)				j = i1;
            			}
            		}
HXLINE( 154)		return (oddNodes != (int)0);
            	}


HX_DEFINE_DYNAMIC_FUNC2(Polygon_obj,contains,return )

bool Polygon_obj::containsPoint( ::openfl::geom::Point point){
            	HX_STACKFRAME(&_hx_pos_e3b2ec681bf6a970_160_containsPoint)
HXDLIN( 160)		return this->contains(point->x,point->y);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Polygon_obj,containsPoint,return )

 ::starling::rendering::IndexData Polygon_obj::triangulate( ::starling::rendering::IndexData indexData,hx::Null< int >  __o_offset){
int offset = __o_offset.Default(0);
            	HX_GC_STACKFRAME(&_hx_pos_e3b2ec681bf6a970_170_triangulate)
HXLINE( 177)		int numVertices = this->get_numVertices();
HXLINE( 178)		int numTriangles = this->get_numTriangles();
HXLINE( 179)		int i;
HXDLIN( 179)		int restIndexPos;
HXDLIN( 179)		int numRestIndices;
HXLINE( 181)		if (hx::IsNull( indexData )) {
HXLINE( 181)			indexData =  ::starling::rendering::IndexData_obj::__alloc( HX_CTX ,(numTriangles * (int)3));
            		}
HXLINE( 182)		if ((numTriangles == (int)0)) {
HXLINE( 182)			return indexData;
            		}
HXLINE( 184)		::openfl::_Vector::IVector_obj::set_length(::starling::geom::Polygon_obj::sRestIndices->data,numVertices);
HXLINE( 185)		{
HXLINE( 185)			int _g1 = (int)0;
HXDLIN( 185)			int _g = numVertices;
HXDLIN( 185)			while((_g1 < _g)){
HXLINE( 185)				_g1 = (_g1 + (int)1);
HXDLIN( 185)				int i1 = (_g1 - (int)1);
HXDLIN( 185)				::openfl::_Vector::IVector_obj::set(::starling::geom::Polygon_obj::sRestIndices->data,i1,i1);
            			}
            		}
HXLINE( 187)		restIndexPos = (int)0;
HXLINE( 188)		numRestIndices = numVertices;
HXLINE( 190)		 ::openfl::geom::Point a = ::starling::utils::Pool_obj::getPoint(null(),null());
HXLINE( 191)		 ::openfl::geom::Point b = ::starling::utils::Pool_obj::getPoint(null(),null());
HXLINE( 192)		 ::openfl::geom::Point c = ::starling::utils::Pool_obj::getPoint(null(),null());
HXLINE( 193)		 ::openfl::geom::Point p = ::starling::utils::Pool_obj::getPoint(null(),null());
HXLINE( 195)		while((numRestIndices > (int)3)){
HXLINE( 202)			int otherIndex;
HXLINE( 203)			bool earFound = false;
HXLINE( 204)			::Dynamic this1 = ::starling::geom::Polygon_obj::sRestIndices->data;
HXDLIN( 204)			int i0 = ( (int)(::openfl::_Vector::IVector_obj::get(this1,hx::Mod(restIndexPos,numRestIndices))) );
HXLINE( 205)			::Dynamic this2 = ::starling::geom::Polygon_obj::sRestIndices->data;
HXDLIN( 205)			int i11 = ( (int)(::openfl::_Vector::IVector_obj::get(this2,hx::Mod((restIndexPos + (int)1),numRestIndices))) );
HXLINE( 206)			::Dynamic this3 = ::starling::geom::Polygon_obj::sRestIndices->data;
HXDLIN( 206)			int i2 = ( (int)(::openfl::_Vector::IVector_obj::get(this3,hx::Mod((restIndexPos + (int)2),numRestIndices))) );
HXLINE( 208)			Float _hx_tmp = ( (Float)(::openfl::_Vector::IVector_obj::get(this->_hx___coords->data,((int)2 * i0))) );
HXDLIN( 208)			a->setTo(_hx_tmp,( (Float)(::openfl::_Vector::IVector_obj::get(this->_hx___coords->data,(((int)2 * i0) + (int)1))) ));
HXLINE( 209)			Float _hx_tmp1 = ( (Float)(::openfl::_Vector::IVector_obj::get(this->_hx___coords->data,((int)2 * i11))) );
HXDLIN( 209)			b->setTo(_hx_tmp1,( (Float)(::openfl::_Vector::IVector_obj::get(this->_hx___coords->data,(((int)2 * i11) + (int)1))) ));
HXLINE( 210)			Float _hx_tmp2 = ( (Float)(::openfl::_Vector::IVector_obj::get(this->_hx___coords->data,((int)2 * i2))) );
HXDLIN( 210)			c->setTo(_hx_tmp2,( (Float)(::openfl::_Vector::IVector_obj::get(this->_hx___coords->data,(((int)2 * i2) + (int)1))) ));
HXLINE( 212)			Float bx = b->x;
HXDLIN( 212)			Float by = b->y;
HXDLIN( 212)			if (((((a->y - by) * (c->x - bx)) + ((bx - a->x) * (c->y - by))) >= (int)0)) {
HXLINE( 214)				earFound = true;
HXLINE( 215)				{
HXLINE( 215)					int _g11 = (int)3;
HXDLIN( 215)					int _g2 = numRestIndices;
HXDLIN( 215)					while((_g11 < _g2)){
HXLINE( 215)						_g11 = (_g11 + (int)1);
HXDLIN( 215)						int i3 = (_g11 - (int)1);
HXLINE( 217)						::Dynamic this4 = ::starling::geom::Polygon_obj::sRestIndices->data;
HXDLIN( 217)						otherIndex = ( (int)(::openfl::_Vector::IVector_obj::get(this4,hx::Mod((restIndexPos + i3),numRestIndices))) );
HXLINE( 218)						Float _hx_tmp3 = ( (Float)(::openfl::_Vector::IVector_obj::get(this->_hx___coords->data,((int)2 * otherIndex))) );
HXDLIN( 218)						p->setTo(_hx_tmp3,( (Float)(::openfl::_Vector::IVector_obj::get(this->_hx___coords->data,(((int)2 * otherIndex) + (int)1))) ));
HXLINE( 220)						if (::starling::utils::MathUtil_obj::isPointInTriangle(p,a,b,c)) {
HXLINE( 222)							earFound = false;
HXLINE( 223)							goto _hx_goto_15;
            						}
            					}
            					_hx_goto_15:;
            				}
            			}
HXLINE( 228)			if (earFound) {
HXLINE( 230)				indexData->addTriangle((i0 + offset),(i11 + offset),(i2 + offset));
HXLINE( 231)				{
HXLINE( 231)					::Dynamic this5 = ::starling::geom::Polygon_obj::sRestIndices->data;
HXDLIN( 231)					::openfl::_Vector::IVector_obj::removeAt(this5,hx::Mod((restIndexPos + (int)1),numRestIndices));
            				}
HXLINE( 233)				numRestIndices = (numRestIndices - (int)1);
HXLINE( 234)				restIndexPos = (int)0;
            			}
            			else {
HXLINE( 238)				restIndexPos = (restIndexPos + (int)1);
HXLINE( 239)				if ((restIndexPos == numRestIndices)) {
HXLINE( 239)					goto _hx_goto_14;
            				}
            			}
            		}
            		_hx_goto_14:;
HXLINE( 243)		::starling::utils::Pool_obj::putPoint(a);
HXLINE( 244)		::starling::utils::Pool_obj::putPoint(b);
HXLINE( 245)		::starling::utils::Pool_obj::putPoint(c);
HXLINE( 246)		::starling::utils::Pool_obj::putPoint(p);
HXLINE( 248)		int _hx_tmp4 = (( (int)(::openfl::_Vector::IVector_obj::get(::starling::geom::Polygon_obj::sRestIndices->data,(int)0)) ) + offset);
HXLINE( 249)		int _hx_tmp5 = (( (int)(::openfl::_Vector::IVector_obj::get(::starling::geom::Polygon_obj::sRestIndices->data,(int)1)) ) + offset);
HXLINE( 248)		indexData->addTriangle(_hx_tmp4,_hx_tmp5,(( (int)(::openfl::_Vector::IVector_obj::get(::starling::geom::Polygon_obj::sRestIndices->data,(int)2)) ) + offset));
HXLINE( 251)		return indexData;
            	}


HX_DEFINE_DYNAMIC_FUNC2(Polygon_obj,triangulate,return )

void Polygon_obj::copyToVertexData( ::starling::rendering::VertexData target,hx::Null< int >  __o_targetVertexID,::String __o_attrName){
int targetVertexID = __o_targetVertexID.Default(0);
::String attrName = __o_attrName.Default(HX_HCSTRING("position","\xa9","\xa0","\xfa","\xca"));
            	HX_STACKFRAME(&_hx_pos_e3b2ec681bf6a970_257_copyToVertexData)
HXLINE( 258)		int numVertices = this->get_numVertices();
HXLINE( 259)		int requiredTargetLength = (targetVertexID + numVertices);
HXLINE( 261)		if ((target->get_numVertices() < requiredTargetLength)) {
HXLINE( 262)			target->set_numVertices(requiredTargetLength);
            		}
HXLINE( 264)		{
HXLINE( 264)			int _g1 = (int)0;
HXDLIN( 264)			int _g = numVertices;
HXDLIN( 264)			while((_g1 < _g)){
HXLINE( 264)				_g1 = (_g1 + (int)1);
HXDLIN( 264)				int i = (_g1 - (int)1);
HXLINE( 265)				::Dynamic this1 = this->_hx___coords->data;
HXDLIN( 265)				Float _hx_tmp = ( (Float)(::openfl::_Vector::IVector_obj::get(this1,(i * (int)2))) );
HXDLIN( 265)				::Dynamic this2 = this->_hx___coords->data;
HXDLIN( 265)				target->setPoint((targetVertexID + i),attrName,_hx_tmp,( (Float)(::openfl::_Vector::IVector_obj::get(this2,((i * (int)2) + (int)1))) ));
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC3(Polygon_obj,copyToVertexData,(void))

::String Polygon_obj::toString(){
            	HX_STACKFRAME(&_hx_pos_e3b2ec681bf6a970_270_toString)
HXLINE( 271)		::String result = HX_("[Polygon",5f,bb,d0,34);
HXLINE( 272)		int numPoints = this->get_numVertices();
HXLINE( 274)		if ((numPoints > (int)0)) {
HXLINE( 274)			result = (result + HX_("\n",0a,00,00,00));
            		}
HXLINE( 276)		{
HXLINE( 276)			int _g1 = (int)0;
HXDLIN( 276)			int _g = numPoints;
HXDLIN( 276)			while((_g1 < _g)){
HXLINE( 276)				_g1 = (_g1 + (int)1);
HXDLIN( 276)				int i = (_g1 - (int)1);
HXLINE( 279)				::Dynamic this1 = this->_hx___coords->data;
HXLINE( 278)				::String result1 = ((((((HX_("  [Vertex ",21,f1,53,07) + i) + HX_(": ",a6,32,00,00)) + HX_("x=",c5,68,00,00)) + ::starling::utils::MathUtil_obj::toFixed(( (Float)(::openfl::_Vector::IVector_obj::get(this1,(i * (int)2))) ),(int)1)) + HX_(", ",74,26,00,00)) + HX_("y=",a4,69,00,00));
HXLINE( 280)				::Dynamic this2 = this->_hx___coords->data;
HXLINE( 278)				::String result2 = ((result1 + ::starling::utils::MathUtil_obj::toFixed(( (Float)(::openfl::_Vector::IVector_obj::get(this2,((i * (int)2) + (int)1))) ),(int)1)) + HX_("]",5d,00,00,00));
HXLINE( 281)				::String result3;
HXDLIN( 281)				if ((i == (numPoints - (int)1))) {
HXLINE( 281)					result3 = HX_("\n",0a,00,00,00);
            				}
            				else {
HXLINE( 281)					result3 = HX_(",\n",5e,26,00,00);
            				}
HXLINE( 278)				result = (result + (result2 + result3));
            			}
            		}
HXLINE( 284)		return (result + HX_("]",5d,00,00,00));
            	}


HX_DEFINE_DYNAMIC_FUNC0(Polygon_obj,toString,return )

bool Polygon_obj::get_isSimple(){
            	HX_STACKFRAME(&_hx_pos_e3b2ec681bf6a970_349_get_isSimple)
HXLINE( 350)		int numCoords = ::openfl::_Vector::IVector_obj::get_length(this->_hx___coords->data);
HXLINE( 351)		if ((numCoords <= (int)6)) {
HXLINE( 351)			return true;
            		}
HXLINE( 353)		int i = (int)0;
HXLINE( 354)		while((i < numCoords)){
HXLINE( 356)			Float ax = ( (Float)(::openfl::_Vector::IVector_obj::get(this->_hx___coords->data,i)) );
HXLINE( 357)			::Dynamic this1 = this->_hx___coords->data;
HXDLIN( 357)			Float ay = ( (Float)(::openfl::_Vector::IVector_obj::get(this1,(i + (int)1))) );
HXLINE( 358)			::Dynamic this2 = this->_hx___coords->data;
HXDLIN( 358)			Float bx = ( (Float)(::openfl::_Vector::IVector_obj::get(this2,hx::Mod((i + (int)2),numCoords))) );
HXLINE( 359)			::Dynamic this3 = this->_hx___coords->data;
HXDLIN( 359)			Float by = ( (Float)(::openfl::_Vector::IVector_obj::get(this3,hx::Mod((i + (int)3),numCoords))) );
HXLINE( 360)			Float endJ = ((i + numCoords) - (int)2);
HXLINE( 362)			int j = (i + (int)4);
HXLINE( 363)			while((j < endJ)){
HXLINE( 365)				::Dynamic this4 = this->_hx___coords->data;
HXDLIN( 365)				Float cx = ( (Float)(::openfl::_Vector::IVector_obj::get(this4,hx::Mod(j,numCoords))) );
HXLINE( 366)				::Dynamic this5 = this->_hx___coords->data;
HXDLIN( 366)				Float cy = ( (Float)(::openfl::_Vector::IVector_obj::get(this5,hx::Mod((j + (int)1),numCoords))) );
HXLINE( 367)				::Dynamic this6 = this->_hx___coords->data;
HXDLIN( 367)				Float dx = ( (Float)(::openfl::_Vector::IVector_obj::get(this6,hx::Mod((j + (int)2),numCoords))) );
HXLINE( 368)				::Dynamic this7 = this->_hx___coords->data;
HXDLIN( 368)				Float dy = ( (Float)(::openfl::_Vector::IVector_obj::get(this7,hx::Mod((j + (int)3),numCoords))) );
HXLINE( 370)				if (::starling::geom::Polygon_obj::areVectorsIntersecting(ax,ay,bx,by,cx,cy,dx,dy)) {
HXLINE( 371)					return false;
            				}
HXLINE( 372)				j = (j + (int)2);
            			}
HXLINE( 374)			i = (i + (int)2);
            		}
HXLINE( 377)		return true;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Polygon_obj,get_isSimple,return )

bool Polygon_obj::get_isConvex(){
            	HX_STACKFRAME(&_hx_pos_e3b2ec681bf6a970_384_get_isConvex)
HXLINE( 385)		int numCoords = ::openfl::_Vector::IVector_obj::get_length(this->_hx___coords->data);
HXLINE( 387)		if ((numCoords < (int)6)) {
HXLINE( 387)			return true;
            		}
            		else {
HXLINE( 390)			int i = (int)0;
HXLINE( 391)			while((i < numCoords)){
HXLINE( 393)				Float ax = ( (Float)(::openfl::_Vector::IVector_obj::get(this->_hx___coords->data,i)) );
HXDLIN( 393)				::Dynamic this1 = this->_hx___coords->data;
HXDLIN( 393)				Float ay = ( (Float)(::openfl::_Vector::IVector_obj::get(this1,(i + (int)1))) );
HXLINE( 394)				::Dynamic this2 = this->_hx___coords->data;
HXLINE( 393)				Float bx = ( (Float)(::openfl::_Vector::IVector_obj::get(this2,hx::Mod((i + (int)2),numCoords))) );
HXLINE( 394)				::Dynamic this3 = this->_hx___coords->data;
HXLINE( 393)				Float by = ( (Float)(::openfl::_Vector::IVector_obj::get(this3,hx::Mod((i + (int)3),numCoords))) );
HXLINE( 395)				::Dynamic this4 = this->_hx___coords->data;
HXLINE( 393)				Float cx = ( (Float)(::openfl::_Vector::IVector_obj::get(this4,hx::Mod((i + (int)4),numCoords))) );
HXLINE( 395)				::Dynamic this5 = this->_hx___coords->data;
HXLINE( 393)				if (!(((((ay - by) * (cx - bx)) + ((bx - ax) * (( (Float)(::openfl::_Vector::IVector_obj::get(this5,hx::Mod((i + (int)5),numCoords))) ) - by))) >= (int)0))) {
HXLINE( 397)					return false;
            				}
HXLINE( 399)				i = (i + (int)2);
            			}
            		}
HXLINE( 403)		return true;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Polygon_obj,get_isConvex,return )

Float Polygon_obj::get_area(){
            	HX_STACKFRAME(&_hx_pos_e3b2ec681bf6a970_409_get_area)
HXLINE( 410)		Float area = (int)0;
HXLINE( 411)		int numCoords = ::openfl::_Vector::IVector_obj::get_length(this->_hx___coords->data);
HXLINE( 413)		if ((numCoords >= (int)6)) {
HXLINE( 415)			int i = (int)0;
HXLINE( 416)			while((i < numCoords)){
HXLINE( 418)				Float area1 = ( (Float)(::openfl::_Vector::IVector_obj::get(this->_hx___coords->data,i)) );
HXDLIN( 418)				::Dynamic this1 = this->_hx___coords->data;
HXDLIN( 418)				area = (area + (area1 * ( (Float)(::openfl::_Vector::IVector_obj::get(this1,hx::Mod((i + (int)3),numCoords))) )));
HXLINE( 419)				::Dynamic this2 = this->_hx___coords->data;
HXDLIN( 419)				Float area2 = ( (Float)(::openfl::_Vector::IVector_obj::get(this2,(i + (int)1))) );
HXDLIN( 419)				::Dynamic this3 = this->_hx___coords->data;
HXDLIN( 419)				area = (area - (area2 * ( (Float)(::openfl::_Vector::IVector_obj::get(this3,hx::Mod((i + (int)2),numCoords))) )));
HXLINE( 420)				i = (i + (int)2);
            			}
            		}
HXLINE( 424)		return ((Float)area / (Float)((Float)2.0));
            	}


HX_DEFINE_DYNAMIC_FUNC0(Polygon_obj,get_area,return )

int Polygon_obj::get_numVertices(){
            	HX_STACKFRAME(&_hx_pos_e3b2ec681bf6a970_433_get_numVertices)
HXDLIN( 433)		return ::Std_obj::_hx_int(((Float)::openfl::_Vector::IVector_obj::get_length(this->_hx___coords->data) / (Float)(int)2));
            	}


HX_DEFINE_DYNAMIC_FUNC0(Polygon_obj,get_numVertices,return )

int Polygon_obj::set_numVertices(int value){
            	HX_STACKFRAME(&_hx_pos_e3b2ec681bf6a970_437_set_numVertices)
HXLINE( 438)		int oldLength = this->get_numVertices();
HXLINE( 439)		{
HXLINE( 439)			::Dynamic this1 = this->_hx___coords->data;
HXDLIN( 439)			::openfl::_Vector::IVector_obj::set_length(this1,(value * (int)2));
            		}
HXLINE( 441)		if ((oldLength < value)) {
HXLINE( 443)			int _g1 = oldLength;
HXDLIN( 443)			int _g = value;
HXDLIN( 443)			while((_g1 < _g)){
HXLINE( 443)				_g1 = (_g1 + (int)1);
HXDLIN( 443)				int i = (_g1 - (int)1);
HXLINE( 444)				{
HXLINE( 444)					 ::openfl::_Vector::AbstractVector this2 = this->_hx___coords;
HXDLIN( 444)					::Dynamic this3 = this->_hx___coords->data;
HXDLIN( 444)					Float value1 = ( (Float)(::openfl::_Vector::IVector_obj::set(this3,((i * (int)2) + (int)1),((Float)0.0))) );
HXDLIN( 444)					::Dynamic this4 = this2->data;
HXDLIN( 444)					::openfl::_Vector::IVector_obj::set(this4,(i * (int)2),value1);
            				}
            			}
            		}
HXLINE( 446)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Polygon_obj,set_numVertices,return )

int Polygon_obj::get_numTriangles(){
            	HX_STACKFRAME(&_hx_pos_e3b2ec681bf6a970_452_get_numTriangles)
HXLINE( 453)		int numVertices = this->get_numVertices();
HXLINE( 454)		if ((numVertices >= (int)3)) {
HXLINE( 454)			return (numVertices - (int)2);
            		}
            		else {
HXLINE( 454)			return (int)0;
            		}
HXDLIN( 454)		return (int)0;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Polygon_obj,get_numTriangles,return )

 ::openfl::_Vector::AbstractVector Polygon_obj::sRestIndices;

 ::starling::geom::Polygon Polygon_obj::createEllipse(Float x,Float y,Float radiusX,Float radiusY,hx::Null< int >  __o_numSides){
int numSides = __o_numSides.Default(-1);
            	HX_GC_STACKFRAME(&_hx_pos_e3b2ec681bf6a970_292_createEllipse)
HXDLIN( 292)		return  ::starling::geom::Ellipse_obj::__alloc( HX_CTX ,x,y,radiusX,radiusY,numSides);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(Polygon_obj,createEllipse,return )

 ::starling::geom::Polygon Polygon_obj::createCircle(Float x,Float y,Float radius,hx::Null< int >  __o_numSides){
int numSides = __o_numSides.Default(-1);
            	HX_GC_STACKFRAME(&_hx_pos_e3b2ec681bf6a970_298_createCircle)
HXDLIN( 298)		return  ::starling::geom::Ellipse_obj::__alloc( HX_CTX ,x,y,radius,radius,numSides);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Polygon_obj,createCircle,return )

 ::starling::geom::Polygon Polygon_obj::createRectangle(Float x,Float y,Float width,Float height){
            	HX_GC_STACKFRAME(&_hx_pos_e3b2ec681bf6a970_305_createRectangle)
HXDLIN( 305)		return  ::starling::geom::Rectangle_obj::__alloc( HX_CTX ,x,y,width,height);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Polygon_obj,createRectangle,return )

bool Polygon_obj::isConvexTriangle(Float ax,Float ay,Float bx,Float by,Float cx,Float cy){
            	HX_STACKFRAME(&_hx_pos_e3b2ec681bf6a970_316_isConvexTriangle)
HXDLIN( 316)		return ((((ay - by) * (cx - bx)) + ((bx - ax) * (cy - by))) >= (int)0);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC6(Polygon_obj,isConvexTriangle,return )

bool Polygon_obj::areVectorsIntersecting(Float ax,Float ay,Float bx,Float by,Float cx,Float cy,Float dx,Float dy){
            	HX_STACKFRAME(&_hx_pos_e3b2ec681bf6a970_322_areVectorsIntersecting)
HXLINE( 323)		bool _hx_tmp;
HXDLIN( 323)		bool _hx_tmp1;
HXDLIN( 323)		if ((ax == bx)) {
HXLINE( 323)			_hx_tmp1 = (ay == by);
            		}
            		else {
HXLINE( 323)			_hx_tmp1 = false;
            		}
HXDLIN( 323)		if (!(_hx_tmp1)) {
HXLINE( 323)			if ((cx == dx)) {
HXLINE( 323)				_hx_tmp = (cy == dy);
            			}
            			else {
HXLINE( 323)				_hx_tmp = false;
            			}
            		}
            		else {
HXLINE( 323)			_hx_tmp = true;
            		}
HXDLIN( 323)		if (_hx_tmp) {
HXLINE( 323)			return false;
            		}
HXLINE( 325)		Float abx = (bx - ax);
HXLINE( 326)		Float aby = (by - ay);
HXLINE( 327)		Float cdx = (dx - cx);
HXLINE( 328)		Float cdy = (dy - cy);
HXLINE( 329)		Float tDen = ((cdy * abx) - (cdx * aby));
HXLINE( 331)		if ((tDen == ((Float)0.0))) {
HXLINE( 331)			return false;
            		}
HXLINE( 333)		Float t = ((Float)((aby * (cx - ax)) - (abx * (cy - ay))) / (Float)tDen);
HXLINE( 335)		bool _hx_tmp2;
HXDLIN( 335)		if (!((t < (int)0))) {
HXLINE( 335)			_hx_tmp2 = (t > (int)1);
            		}
            		else {
HXLINE( 335)			_hx_tmp2 = true;
            		}
HXDLIN( 335)		if (_hx_tmp2) {
HXLINE( 335)			return false;
            		}
HXLINE( 337)		Float s;
HXDLIN( 337)		if ((aby != ((Float)0.0))) {
HXLINE( 337)			s = ((Float)((cy - ay) + (t * cdy)) / (Float)aby);
            		}
            		else {
HXLINE( 337)			s = ((Float)((cx - ax) + (t * cdx)) / (Float)abx);
            		}
HXLINE( 340)		if ((s >= ((Float)0.0))) {
HXLINE( 340)			return (s <= ((Float)1.0));
            		}
            		else {
HXLINE( 340)			return false;
            		}
HXDLIN( 340)		return false;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC8(Polygon_obj,areVectorsIntersecting,return )


hx::ObjectPtr< Polygon_obj > Polygon_obj::__new(::cpp::VirtualArray vertices) {
	hx::ObjectPtr< Polygon_obj > __this = new Polygon_obj();
	__this->__construct(vertices);
	return __this;
}

hx::ObjectPtr< Polygon_obj > Polygon_obj::__alloc(hx::Ctx *_hx_ctx,::cpp::VirtualArray vertices) {
	Polygon_obj *__this = (Polygon_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(Polygon_obj), true, "starling.geom.Polygon"));
	*(void **)__this = Polygon_obj::_hx_vtable;
	__this->__construct(vertices);
	return __this;
}

Polygon_obj::Polygon_obj()
{
}

void Polygon_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Polygon);
	HX_MARK_MEMBER_NAME(_hx___coords,"__coords");
	HX_MARK_END_CLASS();
}

void Polygon_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(_hx___coords,"__coords");
}

hx::Val Polygon_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"area") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_area() ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"clone") ) { return hx::Val( clone_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"reverse") ) { return hx::Val( reverse_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"__coords") ) { return hx::Val( _hx___coords ); }
		if (HX_FIELD_EQ(inName,"contains") ) { return hx::Val( contains_dyn() ); }
		if (HX_FIELD_EQ(inName,"toString") ) { return hx::Val( toString_dyn() ); }
		if (HX_FIELD_EQ(inName,"isSimple") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_isSimple() ); }
		if (HX_FIELD_EQ(inName,"isConvex") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_isConvex() ); }
		if (HX_FIELD_EQ(inName,"get_area") ) { return hx::Val( get_area_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"setVertex") ) { return hx::Val( setVertex_dyn() ); }
		if (HX_FIELD_EQ(inName,"getVertex") ) { return hx::Val( getVertex_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"addVertices") ) { return hx::Val( addVertices_dyn() ); }
		if (HX_FIELD_EQ(inName,"triangulate") ) { return hx::Val( triangulate_dyn() ); }
		if (HX_FIELD_EQ(inName,"numVertices") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_numVertices() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"get_isSimple") ) { return hx::Val( get_isSimple_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_isConvex") ) { return hx::Val( get_isConvex_dyn() ); }
		if (HX_FIELD_EQ(inName,"numTriangles") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_numTriangles() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"containsPoint") ) { return hx::Val( containsPoint_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"get_numVertices") ) { return hx::Val( get_numVertices_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_numVertices") ) { return hx::Val( set_numVertices_dyn() ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"copyToVertexData") ) { return hx::Val( copyToVertexData_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_numTriangles") ) { return hx::Val( get_numTriangles_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool Polygon_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 12:
		if (HX_FIELD_EQ(inName,"sRestIndices") ) { outValue = ( sRestIndices ); return true; }
		if (HX_FIELD_EQ(inName,"createCircle") ) { outValue = createCircle_dyn(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"createEllipse") ) { outValue = createEllipse_dyn(); return true; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"createRectangle") ) { outValue = createRectangle_dyn(); return true; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"isConvexTriangle") ) { outValue = isConvexTriangle_dyn(); return true; }
		break;
	case 22:
		if (HX_FIELD_EQ(inName,"areVectorsIntersecting") ) { outValue = areVectorsIntersecting_dyn(); return true; }
	}
	return false;
}

hx::Val Polygon_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 8:
		if (HX_FIELD_EQ(inName,"__coords") ) { _hx___coords=inValue.Cast<  ::openfl::_Vector::AbstractVector >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"numVertices") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_numVertices(inValue.Cast< int >()) ); }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool Polygon_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 12:
		if (HX_FIELD_EQ(inName,"sRestIndices") ) { sRestIndices=ioValue.Cast<  ::openfl::_Vector::AbstractVector >(); return true; }
	}
	return false;
}

void Polygon_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("__coords","\x3e","\x0f","\xb4","\x70"));
	outFields->push(HX_HCSTRING("isSimple","\xbc","\x9f","\xe8","\x10"));
	outFields->push(HX_HCSTRING("isConvex","\xf1","\x12","\x48","\x20"));
	outFields->push(HX_HCSTRING("area","\x8d","\x8b","\x74","\x40"));
	outFields->push(HX_HCSTRING("numVertices","\x5f","\x10","\x2c","\x56"));
	outFields->push(HX_HCSTRING("numTriangles","\x85","\x39","\xb1","\x26"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo Polygon_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*::openfl::_Vector::AbstractVector*/ ,(int)offsetof(Polygon_obj,_hx___coords),HX_HCSTRING("__coords","\x3e","\x0f","\xb4","\x70")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo Polygon_obj_sStaticStorageInfo[] = {
	{hx::fsObject /*::openfl::_Vector::AbstractVector*/ ,(void *) &Polygon_obj::sRestIndices,HX_HCSTRING("sRestIndices","\xc0","\x34","\x91","\x0b")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static ::String Polygon_obj_sMemberFields[] = {
	HX_HCSTRING("__coords","\x3e","\x0f","\xb4","\x70"),
	HX_HCSTRING("clone","\x5d","\x13","\x63","\x48"),
	HX_HCSTRING("reverse","\x22","\x39","\xfc","\x1a"),
	HX_HCSTRING("addVertices","\x3a","\xf7","\x71","\x9b"),
	HX_HCSTRING("setVertex","\xa6","\x50","\xef","\x00"),
	HX_HCSTRING("getVertex","\x9a","\x64","\x9e","\x1d"),
	HX_HCSTRING("contains","\x1f","\x5a","\x7b","\x2c"),
	HX_HCSTRING("containsPoint","\xb1","\xb9","\xeb","\x92"),
	HX_HCSTRING("triangulate","\x2c","\x65","\x9d","\xe9"),
	HX_HCSTRING("copyToVertexData","\x5e","\x54","\x9b","\x01"),
	HX_HCSTRING("toString","\xac","\xd0","\x6e","\x38"),
	HX_HCSTRING("get_isSimple","\xc5","\x53","\x02","\xc6"),
	HX_HCSTRING("get_isConvex","\xfa","\xc6","\x61","\xd5"),
	HX_HCSTRING("get_area","\x16","\x47","\x2f","\xc0"),
	HX_HCSTRING("get_numVertices","\xf6","\xc7","\x0d","\x17"),
	HX_HCSTRING("set_numVertices","\x02","\x45","\xd9","\x12"),
	HX_HCSTRING("get_numTriangles","\x0e","\x26","\x50","\x2b"),
	::String(null()) };

static void Polygon_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Polygon_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(Polygon_obj::sRestIndices,"sRestIndices");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Polygon_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Polygon_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(Polygon_obj::sRestIndices,"sRestIndices");
};

#endif

hx::Class Polygon_obj::__mClass;

static ::String Polygon_obj_sStaticFields[] = {
	HX_HCSTRING("sRestIndices","\xc0","\x34","\x91","\x0b"),
	HX_HCSTRING("createEllipse","\x42","\x19","\xc9","\xf3"),
	HX_HCSTRING("createCircle","\x2c","\xb2","\x62","\x78"),
	HX_HCSTRING("createRectangle","\x93","\x8d","\x71","\xba"),
	HX_HCSTRING("isConvexTriangle","\xd9","\x66","\x65","\x9e"),
	HX_HCSTRING("areVectorsIntersecting","\xdf","\x5d","\xd7","\x2f"),
	::String(null())
};

void Polygon_obj::__register()
{
	hx::Object *dummy = new Polygon_obj;
	Polygon_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("starling.geom.Polygon","\x0e","\xaa","\xe9","\x45");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Polygon_obj::__GetStatic;
	__mClass->mSetStaticField = &Polygon_obj::__SetStatic;
	__mClass->mMarkFunc = Polygon_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(Polygon_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(Polygon_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< Polygon_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Polygon_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Polygon_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Polygon_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void Polygon_obj::__boot()
{
{
            		HX_BEGIN_LOCAL_FUNC_S0(hx::LocalFunc,_hx_Closure_0) HXARGC(0)
            		 ::Dynamic _hx_run(){
            			HX_GC_STACKFRAME(&_hx_pos_e3b2ec681bf6a970_36_boot)
HXDLIN(  36)			int length = null();
HXDLIN(  36)			bool fixed = null();
HXDLIN(  36)			return  ::openfl::_Vector::AbstractVector_obj::__alloc( HX_CTX , ::openfl::_Vector::IntVector_obj::__alloc( HX_CTX ,length,fixed,null()),null());
            		}
            		HX_END_LOCAL_FUNC0(return)

            	HX_STACKFRAME(&_hx_pos_e3b2ec681bf6a970_36_boot)
HXDLIN(  36)		sRestIndices =  ::Dynamic(new _hx_Closure_0())();
            	}
}

} // end namespace starling
} // end namespace geom
