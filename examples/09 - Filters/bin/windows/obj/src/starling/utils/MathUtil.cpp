// Generated by Haxe 3.4.4
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_openfl_geom_Point
#include <openfl/geom/Point.h>
#endif
#ifndef INCLUDED_openfl_geom_Vector3D
#include <openfl/geom/Vector3D.h>
#endif
#ifndef INCLUDED_starling_utils_MathUtil
#include <starling/utils/MathUtil.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_4aee0e20c1856554_25_intersectLineWithXYPlane,"starling.utils.MathUtil","intersectLineWithXYPlane",0xeccc4463,"starling.utils.MathUtil.intersectLineWithXYPlane","starling/utils/MathUtil.hx",25,0x8f47e88f)
HX_LOCAL_STACK_FRAME(_hx_pos_4aee0e20c1856554_41_isPointInTriangle,"starling.utils.MathUtil","isPointInTriangle",0x3643bb92,"starling.utils.MathUtil.isPointInTriangle","starling/utils/MathUtil.hx",41,0x8f47e88f)
HX_LOCAL_STACK_FRAME(_hx_pos_4aee0e20c1856554_67_normalizeAngle,"starling.utils.MathUtil","normalizeAngle",0xc2e32b87,"starling.utils.MathUtil.normalizeAngle","starling/utils/MathUtil.hx",67,0x8f47e88f)
HX_LOCAL_STACK_FRAME(_hx_pos_4aee0e20c1856554_81_getNextPowerOfTwo,"starling.utils.MathUtil","getNextPowerOfTwo",0xa22ddc98,"starling.utils.MathUtil.getNextPowerOfTwo","starling/utils/MathUtil.hx",81,0x8f47e88f)
HX_LOCAL_STACK_FRAME(_hx_pos_4aee0e20c1856554_96_isEquivalent,"starling.utils.MathUtil","isEquivalent",0x71a06e35,"starling.utils.MathUtil.isEquivalent","starling/utils/MathUtil.hx",96,0x8f47e88f)
HX_LOCAL_STACK_FRAME(_hx_pos_4aee0e20c1856554_103_max,"starling.utils.MathUtil","max",0x84d9ba83,"starling.utils.MathUtil.max","starling/utils/MathUtil.hx",103,0x8f47e88f)
HX_LOCAL_STACK_FRAME(_hx_pos_4aee0e20c1856554_110_min,"starling.utils.MathUtil","min",0x84d9c171,"starling.utils.MathUtil.min","starling/utils/MathUtil.hx",110,0x8f47e88f)
HX_LOCAL_STACK_FRAME(_hx_pos_4aee0e20c1856554_116_clamp,"starling.utils.MathUtil","clamp",0xffd2189a,"starling.utils.MathUtil.clamp","starling/utils/MathUtil.hx",116,0x8f47e88f)
HX_LOCAL_STACK_FRAME(_hx_pos_4aee0e20c1856554_121_minValues,"starling.utils.MathUtil","minValues",0xbb656433,"starling.utils.MathUtil.minValues","starling/utils/MathUtil.hx",121,0x8f47e88f)
HX_LOCAL_STACK_FRAME(_hx_pos_4aee0e20c1856554_134_deg2rad,"starling.utils.MathUtil","deg2rad",0xd57ca108,"starling.utils.MathUtil.deg2rad","starling/utils/MathUtil.hx",134,0x8f47e88f)
HX_LOCAL_STACK_FRAME(_hx_pos_4aee0e20c1856554_140_rad2deg,"starling.utils.MathUtil","rad2deg",0xc7fd5488,"starling.utils.MathUtil.rad2deg","starling/utils/MathUtil.hx",140,0x8f47e88f)
HX_LOCAL_STACK_FRAME(_hx_pos_4aee0e20c1856554_143_toFixed,"starling.utils.MathUtil","toFixed",0x928bd158,"starling.utils.MathUtil.toFixed","starling/utils/MathUtil.hx",143,0x8f47e88f)
HX_LOCAL_STACK_FRAME(_hx_pos_4aee0e20c1856554_19_boot,"starling.utils.MathUtil","boot",0xb26eb773,"starling.utils.MathUtil.boot","starling/utils/MathUtil.hx",19,0x8f47e88f)
namespace starling{
namespace utils{

void MathUtil_obj::__construct() { }

Dynamic MathUtil_obj::__CreateEmpty() { return new MathUtil_obj; }

void *MathUtil_obj::_hx_vtable = 0;

Dynamic MathUtil_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< MathUtil_obj > _hx_result = new MathUtil_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool MathUtil_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x327c2ccf;
}

Float MathUtil_obj::TWO_PI;

 ::openfl::geom::Point MathUtil_obj::intersectLineWithXYPlane( ::openfl::geom::Vector3D pointA, ::openfl::geom::Vector3D pointB, ::openfl::geom::Point out){
            	HX_GC_STACKFRAME(&_hx_pos_4aee0e20c1856554_25_intersectLineWithXYPlane)
HXLINE(  26)		if (hx::IsNull( out )) {
HXLINE(  26)			out =  ::openfl::geom::Point_obj::__alloc( HX_CTX ,null(),null());
            		}
HXLINE(  28)		Float vectorX = (pointB->x - pointA->x);
HXLINE(  29)		Float vectorY = (pointB->y - pointA->y);
HXLINE(  30)		Float vectorZ = (pointB->z - pointA->z);
HXLINE(  31)		Float lambda = ((Float)-(pointA->z) / (Float)vectorZ);
HXLINE(  33)		Float pointA1 = pointA->x;
HXDLIN(  33)		out->x = (pointA1 + (lambda * vectorX));
HXLINE(  34)		Float pointA2 = pointA->y;
HXDLIN(  34)		out->y = (pointA2 + (lambda * vectorY));
HXLINE(  36)		return out;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(MathUtil_obj,intersectLineWithXYPlane,return )

bool MathUtil_obj::isPointInTriangle( ::openfl::geom::Point p, ::openfl::geom::Point a, ::openfl::geom::Point b, ::openfl::geom::Point c){
            	HX_STACKFRAME(&_hx_pos_4aee0e20c1856554_41_isPointInTriangle)
HXLINE(  45)		Float v0x = (c->x - a->x);
HXLINE(  46)		Float v0y = (c->y - a->y);
HXLINE(  47)		Float v1x = (b->x - a->x);
HXLINE(  48)		Float v1y = (b->y - a->y);
HXLINE(  49)		Float v2x = (p->x - a->x);
HXLINE(  50)		Float v2y = (p->y - a->y);
HXLINE(  52)		Float dot00 = ((v0x * v0x) + (v0y * v0y));
HXLINE(  53)		Float dot01 = ((v0x * v1x) + (v0y * v1y));
HXLINE(  54)		Float dot02 = ((v0x * v2x) + (v0y * v2y));
HXLINE(  55)		Float dot11 = ((v1x * v1x) + (v1y * v1y));
HXLINE(  56)		Float dot12 = ((v1x * v2x) + (v1y * v2y));
HXLINE(  58)		Float invDen = ((Float)((Float)1.0) / (Float)((dot00 * dot11) - (dot01 * dot01)));
HXLINE(  59)		Float u = (((dot11 * dot02) - (dot01 * dot12)) * invDen);
HXLINE(  60)		Float v = (((dot00 * dot12) - (dot01 * dot02)) * invDen);
HXLINE(  62)		bool _hx_tmp;
HXDLIN(  62)		if ((u >= (int)0)) {
HXLINE(  62)			_hx_tmp = (v >= (int)0);
            		}
            		else {
HXLINE(  62)			_hx_tmp = false;
            		}
HXDLIN(  62)		if (_hx_tmp) {
HXLINE(  62)			return ((u + v) < (int)1);
            		}
            		else {
HXLINE(  62)			return false;
            		}
HXDLIN(  62)		return false;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(MathUtil_obj,isPointInTriangle,return )

Float MathUtil_obj::normalizeAngle(Float angle){
            	HX_STACKFRAME(&_hx_pos_4aee0e20c1856554_67_normalizeAngle)
HXLINE(  69)		angle = hx::Mod(angle,::starling::utils::MathUtil_obj::TWO_PI);
HXLINE(  72)		if ((angle < -(::Math_obj::PI))) {
HXLINE(  72)			angle = (angle + ::starling::utils::MathUtil_obj::TWO_PI);
            		}
HXLINE(  73)		if ((angle > ::Math_obj::PI)) {
HXLINE(  73)			angle = (angle - ::starling::utils::MathUtil_obj::TWO_PI);
            		}
HXLINE(  75)		return angle;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(MathUtil_obj,normalizeAngle,return )

int MathUtil_obj::getNextPowerOfTwo(Float number){
            	HX_STACKFRAME(&_hx_pos_4aee0e20c1856554_81_getNextPowerOfTwo)
HXDLIN(  81)		bool _hx_tmp;
HXDLIN(  81)		bool _hx_tmp1;
HXDLIN(  81)		if ((::Math_obj::round(number) == number)) {
HXDLIN(  81)			_hx_tmp1 = (number > (int)0);
            		}
            		else {
HXDLIN(  81)			_hx_tmp1 = false;
            		}
HXDLIN(  81)		if (_hx_tmp1) {
HXDLIN(  81)			int _hx_tmp2 = ::Std_obj::_hx_int(number);
HXDLIN(  81)			_hx_tmp = (((int)_hx_tmp2 & (int)::Std_obj::_hx_int((number - (int)1))) == (int)0);
            		}
            		else {
HXDLIN(  81)			_hx_tmp = false;
            		}
HXDLIN(  81)		if (_hx_tmp) {
HXLINE(  82)			return ::Std_obj::_hx_int(number);
            		}
            		else {
HXLINE(  85)			int result = (int)1;
HXLINE(  86)			number = (number - ((Float)0.000000001));
HXLINE(  88)			while((result < number)){
HXLINE(  88)				result = ((int)result << (int)(int)1);
            			}
HXLINE(  89)			return result;
            		}
HXLINE(  81)		return (int)0;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(MathUtil_obj,getNextPowerOfTwo,return )

bool MathUtil_obj::isEquivalent(Float a,Float b,hx::Null< Float >  __o_epsilon){
Float epsilon = __o_epsilon.Default(((Float)0.0001));
            	HX_STACKFRAME(&_hx_pos_4aee0e20c1856554_96_isEquivalent)
HXDLIN(  96)		if (((a - epsilon) < b)) {
HXDLIN(  96)			return ((a + epsilon) > b);
            		}
            		else {
HXDLIN(  96)			return false;
            		}
HXDLIN(  96)		return false;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(MathUtil_obj,isEquivalent,return )

Float MathUtil_obj::max(Float a,Float b){
            	HX_STACKFRAME(&_hx_pos_4aee0e20c1856554_103_max)
HXDLIN( 103)		if ((a > b)) {
HXDLIN( 103)			return a;
            		}
            		else {
HXDLIN( 103)			return b;
            		}
HXDLIN( 103)		return ((Float)0.);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(MathUtil_obj,max,return )

Float MathUtil_obj::min(Float a,Float b){
            	HX_STACKFRAME(&_hx_pos_4aee0e20c1856554_110_min)
HXDLIN( 110)		if ((a < b)) {
HXDLIN( 110)			return a;
            		}
            		else {
HXDLIN( 110)			return b;
            		}
HXDLIN( 110)		return ((Float)0.);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(MathUtil_obj,min,return )

Float MathUtil_obj::clamp(Float value,Float min,Float max){
            	HX_STACKFRAME(&_hx_pos_4aee0e20c1856554_116_clamp)
HXDLIN( 116)		if ((value < min)) {
HXDLIN( 116)			return min;
            		}
            		else {
HXDLIN( 116)			if ((value > max)) {
HXDLIN( 116)				return max;
            			}
            			else {
HXDLIN( 116)				return value;
            			}
            		}
HXDLIN( 116)		return ((Float)0.);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(MathUtil_obj,clamp,return )

Float MathUtil_obj::minValues(::Array< Float > values){
            	HX_STACKFRAME(&_hx_pos_4aee0e20c1856554_121_minValues)
HXLINE( 122)		if ((values->length == (int)0)) {
HXLINE( 123)			return ((Float)0.0);
            		}
HXLINE( 124)		Float min = values->__get((int)0);
HXLINE( 125)		{
HXLINE( 125)			int _g1 = (int)1;
HXDLIN( 125)			int _g = values->length;
HXDLIN( 125)			while((_g1 < _g)){
HXLINE( 125)				_g1 = (_g1 + (int)1);
HXDLIN( 125)				int i = (_g1 - (int)1);
HXLINE( 126)				if ((values->__get(i) < min)) {
HXLINE( 127)					min = values->__get(i);
            				}
            			}
            		}
HXLINE( 128)		return min;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(MathUtil_obj,minValues,return )

Float MathUtil_obj::deg2rad(Float deg){
            	HX_STACKFRAME(&_hx_pos_4aee0e20c1856554_134_deg2rad)
HXDLIN( 134)		return (((Float)deg / (Float)((Float)180.0)) * ::Math_obj::PI);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(MathUtil_obj,deg2rad,return )

Float MathUtil_obj::rad2deg(Float rad){
            	HX_STACKFRAME(&_hx_pos_4aee0e20c1856554_140_rad2deg)
HXDLIN( 140)		return (((Float)rad / (Float)::Math_obj::PI) * ((Float)180.0));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(MathUtil_obj,rad2deg,return )

::String MathUtil_obj::toFixed(Float value,int precision){
            	HX_STACKFRAME(&_hx_pos_4aee0e20c1856554_143_toFixed)
HXLINE( 144)		int sign;
HXDLIN( 144)		if ((value > (int)0)) {
HXLINE( 144)			sign = (int)1;
            		}
            		else {
HXLINE( 144)			sign = (int)-1;
            		}
HXLINE( 145)		int mult;
HXDLIN( 145)		if ((precision <= (int)0)) {
HXLINE( 145)			mult = (int)1;
            		}
            		else {
HXLINE( 145)			mult = (precision * (int)10);
            		}
HXLINE( 146)		return ::Std_obj::string(((Float)(sign * ::Math_obj::round((value * mult))) / (Float)mult));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(MathUtil_obj,toFixed,return )


MathUtil_obj::MathUtil_obj()
{
}

bool MathUtil_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"max") ) { outValue = max_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"min") ) { outValue = min_dyn(); return true; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"clamp") ) { outValue = clamp_dyn(); return true; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"TWO_PI") ) { outValue = ( TWO_PI ); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"deg2rad") ) { outValue = deg2rad_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"rad2deg") ) { outValue = rad2deg_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"toFixed") ) { outValue = toFixed_dyn(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"minValues") ) { outValue = minValues_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"isEquivalent") ) { outValue = isEquivalent_dyn(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"normalizeAngle") ) { outValue = normalizeAngle_dyn(); return true; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"isPointInTriangle") ) { outValue = isPointInTriangle_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"getNextPowerOfTwo") ) { outValue = getNextPowerOfTwo_dyn(); return true; }
		break;
	case 24:
		if (HX_FIELD_EQ(inName,"intersectLineWithXYPlane") ) { outValue = intersectLineWithXYPlane_dyn(); return true; }
	}
	return false;
}

bool MathUtil_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"TWO_PI") ) { TWO_PI=ioValue.Cast< Float >(); return true; }
	}
	return false;
}

#if HXCPP_SCRIPTABLE
static hx::StorageInfo *MathUtil_obj_sMemberStorageInfo = 0;
static hx::StaticInfo MathUtil_obj_sStaticStorageInfo[] = {
	{hx::fsFloat,(void *) &MathUtil_obj::TWO_PI,HX_HCSTRING("TWO_PI","\x2c","\xfe","\x56","\xe2")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static void MathUtil_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(MathUtil_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(MathUtil_obj::TWO_PI,"TWO_PI");
};

#ifdef HXCPP_VISIT_ALLOCS
static void MathUtil_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(MathUtil_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(MathUtil_obj::TWO_PI,"TWO_PI");
};

#endif

hx::Class MathUtil_obj::__mClass;

static ::String MathUtil_obj_sStaticFields[] = {
	HX_HCSTRING("TWO_PI","\x2c","\xfe","\x56","\xe2"),
	HX_HCSTRING("intersectLineWithXYPlane","\xa2","\x8a","\x08","\xfe"),
	HX_HCSTRING("isPointInTriangle","\x73","\xa3","\xd8","\x49"),
	HX_HCSTRING("normalizeAngle","\x06","\xfd","\xf8","\x43"),
	HX_HCSTRING("getNextPowerOfTwo","\x79","\xc4","\xc2","\xb5"),
	HX_HCSTRING("isEquivalent","\xf4","\x91","\x16","\x4e"),
	HX_HCSTRING("max","\xa4","\x0a","\x53","\x00"),
	HX_HCSTRING("min","\x92","\x11","\x53","\x00"),
	HX_HCSTRING("clamp","\xfb","\x72","\x58","\x48"),
	HX_HCSTRING("minValues","\x14","\x03","\xff","\xa8"),
	HX_HCSTRING("deg2rad","\xa9","\x15","\x17","\x10"),
	HX_HCSTRING("rad2deg","\x29","\xc9","\x97","\x02"),
	HX_HCSTRING("toFixed","\xf9","\x45","\x26","\xcd"),
	::String(null())
};

void MathUtil_obj::__register()
{
	hx::Object *dummy = new MathUtil_obj;
	MathUtil_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("starling.utils.MathUtil","\xcd","\xf4","\xef","\x73");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &MathUtil_obj::__GetStatic;
	__mClass->mSetStaticField = &MathUtil_obj::__SetStatic;
	__mClass->mMarkFunc = MathUtil_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(MathUtil_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = hx::TCanCast< MathUtil_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = MathUtil_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = MathUtil_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = MathUtil_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void MathUtil_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_4aee0e20c1856554_19_boot)
HXDLIN(  19)		TWO_PI = (::Math_obj::PI * ((Float)2.0));
            	}
}

} // end namespace starling
} // end namespace utils
