// Generated by Haxe 3.4.4
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_openfl__Vector_AbstractVector
#include <openfl/_Vector/AbstractVector.h>
#endif
#ifndef INCLUDED_openfl__Vector_IVector
#include <openfl/_Vector/IVector.h>
#endif
#ifndef INCLUDED_openfl__Vector_ObjectVector
#include <openfl/_Vector/ObjectVector.h>
#endif
#ifndef INCLUDED_openfl_errors_ArgumentError
#include <openfl/errors/ArgumentError.h>
#endif
#ifndef INCLUDED_openfl_errors_Error
#include <openfl/errors/Error.h>
#endif
#ifndef INCLUDED_openfl_geom_Matrix
#include <openfl/geom/Matrix.h>
#endif
#ifndef INCLUDED_openfl_geom_Matrix3D
#include <openfl/geom/Matrix3D.h>
#endif
#ifndef INCLUDED_openfl_geom_Point
#include <openfl/geom/Point.h>
#endif
#ifndef INCLUDED_openfl_geom_Rectangle
#include <openfl/geom/Rectangle.h>
#endif
#ifndef INCLUDED_openfl_geom_Vector3D
#include <openfl/geom/Vector3D.h>
#endif
#ifndef INCLUDED_starling_utils_MathUtil
#include <starling/utils/MathUtil.h>
#endif
#ifndef INCLUDED_starling_utils_MatrixUtil
#include <starling/utils/MatrixUtil.h>
#endif
#ifndef INCLUDED_starling_utils_RectangleUtil
#include <starling/utils/RectangleUtil.h>
#endif
#ifndef INCLUDED_starling_utils_ScaleMode
#include <starling/utils/ScaleMode.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_2aa2a0cb645b21ab_34_intersect,"starling.utils.RectangleUtil","intersect",0xbfd9827f,"starling.utils.RectangleUtil.intersect","starling/utils/RectangleUtil.hx",34,0x1d928032)
HX_LOCAL_STACK_FRAME(_hx_pos_2aa2a0cb645b21ab_63_fit,"starling.utils.RectangleUtil","fit",0x03fb4b71,"starling.utils.RectangleUtil.fit","starling/utils/RectangleUtil.hx",63,0x1d928032)
HX_LOCAL_STACK_FRAME(_hx_pos_2aa2a0cb645b21ab_97_nextSuitableScaleFactor,"starling.utils.RectangleUtil","nextSuitableScaleFactor",0x523e757f,"starling.utils.RectangleUtil.nextSuitableScaleFactor","starling/utils/RectangleUtil.hx",97,0x1d928032)
HX_LOCAL_STACK_FRAME(_hx_pos_2aa2a0cb645b21ab_125_normalize,"starling.utils.RectangleUtil","normalize",0x2905b92d,"starling.utils.RectangleUtil.normalize","starling/utils/RectangleUtil.hx",125,0x1d928032)
HX_LOCAL_STACK_FRAME(_hx_pos_2aa2a0cb645b21ab_142_extend,"starling.utils.RectangleUtil","extend",0x858b0c3a,"starling.utils.RectangleUtil.extend","starling/utils/RectangleUtil.hx",142,0x1d928032)
HX_LOCAL_STACK_FRAME(_hx_pos_2aa2a0cb645b21ab_151_extendToWholePixels,"starling.utils.RectangleUtil","extendToWholePixels",0xeaee1d6f,"starling.utils.RectangleUtil.extendToWholePixels","starling/utils/RectangleUtil.hx",151,0x1d928032)
HX_LOCAL_STACK_FRAME(_hx_pos_2aa2a0cb645b21ab_165_getBounds,"starling.utils.RectangleUtil","getBounds",0x5fd8914b,"starling.utils.RectangleUtil.getBounds","starling/utils/RectangleUtil.hx",165,0x1d928032)
HX_LOCAL_STACK_FRAME(_hx_pos_2aa2a0cb645b21ab_194_getBoundsProjected,"starling.utils.RectangleUtil","getBoundsProjected",0x9fa9e0ad,"starling.utils.RectangleUtil.getBoundsProjected","starling/utils/RectangleUtil.hx",194,0x1d928032)
HX_LOCAL_STACK_FRAME(_hx_pos_2aa2a0cb645b21ab_226_getPositions,"starling.utils.RectangleUtil","getPositions",0x870cd294,"starling.utils.RectangleUtil.getPositions","starling/utils/RectangleUtil.hx",226,0x1d928032)
HX_LOCAL_STACK_FRAME(_hx_pos_2aa2a0cb645b21ab_243_compare,"starling.utils.RectangleUtil","compare",0x672bf245,"starling.utils.RectangleUtil.compare","starling/utils/RectangleUtil.hx",243,0x1d928032)
HX_LOCAL_STACK_FRAME(_hx_pos_2aa2a0cb645b21ab_25_boot,"starling.utils.RectangleUtil","boot",0x75466692,"starling.utils.RectangleUtil.boot","starling/utils/RectangleUtil.hx",25,0x1d928032)
HX_LOCAL_STACK_FRAME(_hx_pos_2aa2a0cb645b21ab_26_boot,"starling.utils.RectangleUtil","boot",0x75466692,"starling.utils.RectangleUtil.boot","starling/utils/RectangleUtil.hx",26,0x1d928032)
HX_LOCAL_STACK_FRAME(_hx_pos_2aa2a0cb645b21ab_28_boot,"starling.utils.RectangleUtil","boot",0x75466692,"starling.utils.RectangleUtil.boot","starling/utils/RectangleUtil.hx",28,0x1d928032)
namespace starling{
namespace utils{

void RectangleUtil_obj::__construct() { }

Dynamic RectangleUtil_obj::__CreateEmpty() { return new RectangleUtil_obj; }

void *RectangleUtil_obj::_hx_vtable = 0;

Dynamic RectangleUtil_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< RectangleUtil_obj > _hx_result = new RectangleUtil_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool RectangleUtil_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x0e2dab68;
}

 ::openfl::geom::Point RectangleUtil_obj::sPoint;

 ::openfl::geom::Vector3D RectangleUtil_obj::sPoint3D;

 ::openfl::_Vector::AbstractVector RectangleUtil_obj::sPositions;

 ::openfl::geom::Rectangle RectangleUtil_obj::intersect( ::openfl::geom::Rectangle rect1, ::openfl::geom::Rectangle rect2, ::openfl::geom::Rectangle out){
            	HX_GC_STACKFRAME(&_hx_pos_2aa2a0cb645b21ab_34_intersect)
HXLINE(  35)		if (hx::IsNull( out )) {
HXLINE(  35)			out =  ::openfl::geom::Rectangle_obj::__alloc( HX_CTX ,null(),null(),null(),null());
            		}
HXLINE(  37)		Float left;
HXDLIN(  37)		if ((rect1->x > rect2->x)) {
HXLINE(  37)			left = rect1->x;
            		}
            		else {
HXLINE(  37)			left = rect2->x;
            		}
HXLINE(  38)		Float right;
HXDLIN(  38)		Float right1 = rect1->get_right();
HXDLIN(  38)		if ((right1 < rect2->get_right())) {
HXLINE(  38)			right = rect1->get_right();
            		}
            		else {
HXLINE(  38)			right = rect2->get_right();
            		}
HXLINE(  39)		Float top;
HXDLIN(  39)		if ((rect1->y > rect2->y)) {
HXLINE(  39)			top = rect1->y;
            		}
            		else {
HXLINE(  39)			top = rect2->y;
            		}
HXLINE(  40)		Float bottom;
HXDLIN(  40)		Float bottom1 = rect1->get_bottom();
HXDLIN(  40)		if ((bottom1 < rect2->get_bottom())) {
HXLINE(  40)			bottom = rect1->get_bottom();
            		}
            		else {
HXLINE(  40)			bottom = rect2->get_bottom();
            		}
HXLINE(  42)		bool _hx_tmp;
HXDLIN(  42)		if (!((left > right))) {
HXLINE(  42)			_hx_tmp = (top > bottom);
            		}
            		else {
HXLINE(  42)			_hx_tmp = true;
            		}
HXDLIN(  42)		if (_hx_tmp) {
HXLINE(  43)			out->setEmpty();
            		}
            		else {
HXLINE(  45)			out->setTo(left,top,(right - left),(bottom - top));
            		}
HXLINE(  47)		return out;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(RectangleUtil_obj,intersect,return )

 ::openfl::geom::Rectangle RectangleUtil_obj::fit( ::openfl::geom::Rectangle rectangle, ::openfl::geom::Rectangle into,::String __o_scaleMode,hx::Null< bool >  __o_pixelPerfect, ::openfl::geom::Rectangle out){
::String scaleMode = __o_scaleMode.Default(HX_HCSTRING("showAll","\x24","\x58","\x96","\x7b"));
bool pixelPerfect = __o_pixelPerfect.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_2aa2a0cb645b21ab_63_fit)
HXLINE(  64)		if (!(::starling::utils::ScaleMode_obj::isValid(scaleMode))) {
HXLINE(  64)			HX_STACK_DO_THROW( ::openfl::errors::ArgumentError_obj::__alloc( HX_CTX ,(HX_("Invalid scaleMode: ",2a,c8,75,04) + scaleMode)));
            		}
HXLINE(  65)		if (hx::IsNull( out )) {
HXLINE(  65)			out =  ::openfl::geom::Rectangle_obj::__alloc( HX_CTX ,null(),null(),null(),null());
            		}
HXLINE(  67)		Float width = rectangle->width;
HXLINE(  68)		Float height = rectangle->height;
HXLINE(  69)		Float factorX = ((Float)into->width / (Float)width);
HXLINE(  70)		Float factorY = ((Float)into->height / (Float)height);
HXLINE(  71)		Float factor = ((Float)1.0);
HXLINE(  73)		if ((scaleMode == HX_("showAll",24,58,96,7b))) {
HXLINE(  75)			if ((factorX < factorY)) {
HXLINE(  75)				factor = factorX;
            			}
            			else {
HXLINE(  75)				factor = factorY;
            			}
HXLINE(  76)			if (pixelPerfect) {
HXLINE(  76)				factor = ::starling::utils::RectangleUtil_obj::nextSuitableScaleFactor(factor,false);
            			}
            		}
            		else {
HXLINE(  78)			if ((scaleMode == HX_("noBorder",0d,48,2a,34))) {
HXLINE(  80)				if ((factorX > factorY)) {
HXLINE(  80)					factor = factorX;
            				}
            				else {
HXLINE(  80)					factor = factorY;
            				}
HXLINE(  81)				if (pixelPerfect) {
HXLINE(  81)					factor = ::starling::utils::RectangleUtil_obj::nextSuitableScaleFactor(factor,true);
            				}
            			}
            		}
HXLINE(  84)		width = (width * factor);
HXLINE(  85)		height = (height * factor);
HXLINE(  88)		Float into1 = into->x;
HXDLIN(  88)		Float _hx_tmp = (into1 + ((Float)(into->width - width) / (Float)(int)2));
HXLINE(  89)		Float into2 = into->y;
HXLINE(  87)		out->setTo(_hx_tmp,(into2 + ((Float)(into->height - height) / (Float)(int)2)),width,height);
HXLINE(  92)		return out;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(RectangleUtil_obj,fit,return )

Float RectangleUtil_obj::nextSuitableScaleFactor(Float factor,bool up){
            	HX_STACKFRAME(&_hx_pos_2aa2a0cb645b21ab_97_nextSuitableScaleFactor)
HXLINE(  98)		Float divisor = ((Float)1.0);
HXLINE( 100)		if (up) {
HXLINE( 102)			if ((factor >= ((Float)0.5))) {
HXLINE( 102)				return ::Math_obj::ceil(factor);
            			}
            			else {
HXLINE( 105)				while((((Float)((Float)1.0) / (Float)(divisor + (int)1)) > factor)){
HXLINE( 106)					divisor = (divisor + (int)1);
            				}
            			}
            		}
            		else {
HXLINE( 111)			if ((factor >= ((Float)1.0))) {
HXLINE( 111)				return ::Math_obj::floor(factor);
            			}
            			else {
HXLINE( 114)				while((((Float)((Float)1.0) / (Float)divisor) > factor)){
HXLINE( 115)					divisor = (divisor + (int)1);
            				}
            			}
            		}
HXLINE( 119)		return ((Float)((Float)1.0) / (Float)divisor);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(RectangleUtil_obj,nextSuitableScaleFactor,return )

void RectangleUtil_obj::normalize( ::openfl::geom::Rectangle rect){
            	HX_STACKFRAME(&_hx_pos_2aa2a0cb645b21ab_125_normalize)
HXLINE( 126)		if ((rect->width < (int)0)) {
HXLINE( 128)			rect->width = -(rect->width);
HXLINE( 129)			 ::openfl::geom::Rectangle rect1 = rect;
HXDLIN( 129)			rect1->x = (rect1->x - rect->width);
            		}
HXLINE( 132)		if ((rect->height < (int)0)) {
HXLINE( 134)			rect->height = -(rect->height);
HXLINE( 135)			 ::openfl::geom::Rectangle rect2 = rect;
HXDLIN( 135)			rect2->y = (rect2->y - rect->height);
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(RectangleUtil_obj,normalize,(void))

void RectangleUtil_obj::extend( ::openfl::geom::Rectangle rect,hx::Null< Float >  __o_left,hx::Null< Float >  __o_right,hx::Null< Float >  __o_top,hx::Null< Float >  __o_bottom){
Float left = __o_left.Default(0);
Float right = __o_right.Default(0);
Float top = __o_top.Default(0);
Float bottom = __o_bottom.Default(0);
            	HX_STACKFRAME(&_hx_pos_2aa2a0cb645b21ab_142_extend)
HXLINE( 143)		 ::openfl::geom::Rectangle rect1 = rect;
HXDLIN( 143)		rect1->x = (rect1->x - left);
HXLINE( 144)		 ::openfl::geom::Rectangle rect2 = rect;
HXDLIN( 144)		rect2->y = (rect2->y - top);
HXLINE( 145)		 ::openfl::geom::Rectangle rect3 = rect;
HXDLIN( 145)		rect3->width = (rect3->width + (left + right));
HXLINE( 146)		 ::openfl::geom::Rectangle rect4 = rect;
HXDLIN( 146)		rect4->height = (rect4->height + (top + bottom));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(RectangleUtil_obj,extend,(void))

void RectangleUtil_obj::extendToWholePixels( ::openfl::geom::Rectangle rect,hx::Null< Float >  __o_scaleFactor){
Float scaleFactor = __o_scaleFactor.Default(1);
            	HX_STACKFRAME(&_hx_pos_2aa2a0cb645b21ab_151_extendToWholePixels)
HXLINE( 152)		Float left = ((Float)::Math_obj::floor((rect->x * scaleFactor)) / (Float)scaleFactor);
HXLINE( 153)		Float top = ((Float)::Math_obj::floor((rect->y * scaleFactor)) / (Float)scaleFactor);
HXLINE( 154)		Float right = ((Float)::Math_obj::ceil((rect->get_right() * scaleFactor)) / (Float)scaleFactor);
HXLINE( 155)		Float bottom = ((Float)::Math_obj::ceil((rect->get_bottom() * scaleFactor)) / (Float)scaleFactor);
HXLINE( 157)		rect->setTo(left,top,(right - left),(bottom - top));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(RectangleUtil_obj,extendToWholePixels,(void))

 ::openfl::geom::Rectangle RectangleUtil_obj::getBounds( ::openfl::geom::Rectangle rectangle, ::openfl::geom::Matrix matrix, ::openfl::geom::Rectangle out){
            	HX_GC_STACKFRAME(&_hx_pos_2aa2a0cb645b21ab_165_getBounds)
HXLINE( 166)		if (hx::IsNull( out )) {
HXLINE( 166)			out =  ::openfl::geom::Rectangle_obj::__alloc( HX_CTX ,null(),null(),null(),null());
            		}
HXLINE( 168)		Float minX = ((Float)1.79e+308);
HXDLIN( 168)		Float maxX = ((Float)-1.79e+308);
HXLINE( 169)		Float minY = ((Float)1.79e+308);
HXDLIN( 169)		Float maxY = ((Float)-1.79e+308);
HXLINE( 170)		 ::openfl::_Vector::AbstractVector positions = ::starling::utils::RectangleUtil_obj::getPositions(rectangle,::starling::utils::RectangleUtil_obj::sPositions);
HXLINE( 172)		{
HXLINE( 172)			int _g = (int)0;
HXDLIN( 172)			while((_g < (int)4)){
HXLINE( 172)				_g = (_g + (int)1);
HXDLIN( 172)				int i = (_g - (int)1);
HXLINE( 174)				Float _hx_tmp = ( ( ::openfl::geom::Point)(::openfl::_Vector::IVector_obj::get(positions->data,i)) )->x;
HXDLIN( 174)				::starling::utils::MatrixUtil_obj::transformCoords(matrix,_hx_tmp,( ( ::openfl::geom::Point)(::openfl::_Vector::IVector_obj::get(positions->data,i)) )->y,::starling::utils::RectangleUtil_obj::sPoint);
HXLINE( 176)				if ((minX > ::starling::utils::RectangleUtil_obj::sPoint->x)) {
HXLINE( 176)					minX = ::starling::utils::RectangleUtil_obj::sPoint->x;
            				}
HXLINE( 177)				if ((maxX < ::starling::utils::RectangleUtil_obj::sPoint->x)) {
HXLINE( 177)					maxX = ::starling::utils::RectangleUtil_obj::sPoint->x;
            				}
HXLINE( 178)				if ((minY > ::starling::utils::RectangleUtil_obj::sPoint->y)) {
HXLINE( 178)					minY = ::starling::utils::RectangleUtil_obj::sPoint->y;
            				}
HXLINE( 179)				if ((maxY < ::starling::utils::RectangleUtil_obj::sPoint->y)) {
HXLINE( 179)					maxY = ::starling::utils::RectangleUtil_obj::sPoint->y;
            				}
            			}
            		}
HXLINE( 182)		out->setTo(minX,minY,(maxX - minX),(maxY - minY));
HXLINE( 183)		return out;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(RectangleUtil_obj,getBounds,return )

 ::openfl::geom::Rectangle RectangleUtil_obj::getBoundsProjected( ::openfl::geom::Rectangle rectangle, ::openfl::geom::Matrix3D matrix, ::openfl::geom::Vector3D camPos, ::openfl::geom::Rectangle out){
            	HX_GC_STACKFRAME(&_hx_pos_2aa2a0cb645b21ab_194_getBoundsProjected)
HXLINE( 195)		if (hx::IsNull( out )) {
HXLINE( 195)			out =  ::openfl::geom::Rectangle_obj::__alloc( HX_CTX ,null(),null(),null(),null());
            		}
HXLINE( 196)		if (hx::IsNull( camPos )) {
HXLINE( 196)			HX_STACK_DO_THROW( ::openfl::errors::ArgumentError_obj::__alloc( HX_CTX ,HX_("camPos must not be null",1b,c7,fc,18)));
            		}
HXLINE( 198)		Float minX = ((Float)1.79e+308);
HXDLIN( 198)		Float maxX = ((Float)-1.79e+308);
HXLINE( 199)		Float minY = ((Float)1.79e+308);
HXDLIN( 199)		Float maxY = ((Float)-1.79e+308);
HXLINE( 200)		 ::openfl::_Vector::AbstractVector positions = ::starling::utils::RectangleUtil_obj::getPositions(rectangle,::starling::utils::RectangleUtil_obj::sPositions);
HXLINE( 202)		{
HXLINE( 202)			int _g = (int)0;
HXDLIN( 202)			while((_g < (int)4)){
HXLINE( 202)				_g = (_g + (int)1);
HXDLIN( 202)				int i = (_g - (int)1);
HXLINE( 204)				 ::openfl::geom::Point position = ( ( ::openfl::geom::Point)(::openfl::_Vector::IVector_obj::get(positions->data,i)) );
HXLINE( 206)				if (hx::IsNotNull( matrix )) {
HXLINE( 207)					::starling::utils::MatrixUtil_obj::transformCoords3D(matrix,position->x,position->y,(int)0,::starling::utils::RectangleUtil_obj::sPoint3D);
            				}
            				else {
HXLINE( 209)					::starling::utils::RectangleUtil_obj::sPoint3D->setTo(position->x,position->y,(int)0);
            				}
HXLINE( 211)				::starling::utils::MathUtil_obj::intersectLineWithXYPlane(camPos,::starling::utils::RectangleUtil_obj::sPoint3D,::starling::utils::RectangleUtil_obj::sPoint);
HXLINE( 213)				if ((minX > ::starling::utils::RectangleUtil_obj::sPoint->x)) {
HXLINE( 213)					minX = ::starling::utils::RectangleUtil_obj::sPoint->x;
            				}
HXLINE( 214)				if ((maxX < ::starling::utils::RectangleUtil_obj::sPoint->x)) {
HXLINE( 214)					maxX = ::starling::utils::RectangleUtil_obj::sPoint->x;
            				}
HXLINE( 215)				if ((minY > ::starling::utils::RectangleUtil_obj::sPoint->y)) {
HXLINE( 215)					minY = ::starling::utils::RectangleUtil_obj::sPoint->y;
            				}
HXLINE( 216)				if ((maxY < ::starling::utils::RectangleUtil_obj::sPoint->y)) {
HXLINE( 216)					maxY = ::starling::utils::RectangleUtil_obj::sPoint->y;
            				}
            			}
            		}
HXLINE( 219)		out->setTo(minX,minY,(maxX - minX),(maxY - minY));
HXLINE( 220)		return out;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(RectangleUtil_obj,getBoundsProjected,return )

 ::openfl::_Vector::AbstractVector RectangleUtil_obj::getPositions( ::openfl::geom::Rectangle rectangle, ::openfl::_Vector::AbstractVector out){
            	HX_GC_STACKFRAME(&_hx_pos_2aa2a0cb645b21ab_226_getPositions)
HXLINE( 227)		if (hx::IsNull( out )) {
HXLINE( 227)			out =  ::openfl::_Vector::AbstractVector_obj::__alloc( HX_CTX , ::openfl::_Vector::ObjectVector_obj::__alloc( HX_CTX ,(int)4,true,null()),null());
            		}
HXLINE( 229)		{
HXLINE( 229)			int _g = (int)0;
HXDLIN( 229)			while((_g < (int)4)){
HXLINE( 229)				_g = (_g + (int)1);
HXDLIN( 229)				int i = (_g - (int)1);
HXLINE( 230)				if (hx::IsNull( ( ( ::openfl::geom::Point)(::openfl::_Vector::IVector_obj::get(out->data,i)) ) )) {
HXLINE( 230)					 ::openfl::geom::Point value =  ::openfl::geom::Point_obj::__alloc( HX_CTX ,null(),null());
HXDLIN( 230)					::openfl::_Vector::IVector_obj::set(out->data,i,value);
            				}
            			}
            		}
HXLINE( 232)		( ( ::openfl::geom::Point)(::openfl::_Vector::IVector_obj::get(out->data,(int)0)) )->x = rectangle->get_left();
HXDLIN( 232)		( ( ::openfl::geom::Point)(::openfl::_Vector::IVector_obj::get(out->data,(int)0)) )->y = rectangle->get_top();
HXLINE( 233)		( ( ::openfl::geom::Point)(::openfl::_Vector::IVector_obj::get(out->data,(int)1)) )->x = rectangle->get_right();
HXDLIN( 233)		( ( ::openfl::geom::Point)(::openfl::_Vector::IVector_obj::get(out->data,(int)1)) )->y = rectangle->get_top();
HXLINE( 234)		( ( ::openfl::geom::Point)(::openfl::_Vector::IVector_obj::get(out->data,(int)2)) )->x = rectangle->get_left();
HXDLIN( 234)		( ( ::openfl::geom::Point)(::openfl::_Vector::IVector_obj::get(out->data,(int)2)) )->y = rectangle->get_bottom();
HXLINE( 235)		( ( ::openfl::geom::Point)(::openfl::_Vector::IVector_obj::get(out->data,(int)3)) )->x = rectangle->get_right();
HXDLIN( 235)		( ( ::openfl::geom::Point)(::openfl::_Vector::IVector_obj::get(out->data,(int)3)) )->y = rectangle->get_bottom();
HXLINE( 236)		return out;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(RectangleUtil_obj,getPositions,return )

bool RectangleUtil_obj::compare( ::openfl::geom::Rectangle r1, ::openfl::geom::Rectangle r2,hx::Null< Float >  __o_e){
Float e = __o_e.Default(((Float)0.0001));
            	HX_STACKFRAME(&_hx_pos_2aa2a0cb645b21ab_243_compare)
HXDLIN( 243)		if (hx::IsNull( r1 )) {
HXDLIN( 243)			return hx::IsNull( r2 );
            		}
            		else {
HXLINE( 244)			if (hx::IsNull( r2 )) {
HXLINE( 244)				return false;
            			}
            			else {
HXLINE( 247)				bool _hx_tmp;
HXDLIN( 247)				bool _hx_tmp1;
HXDLIN( 247)				bool _hx_tmp2;
HXDLIN( 247)				bool _hx_tmp3;
HXDLIN( 247)				bool _hx_tmp4;
HXDLIN( 247)				bool _hx_tmp5;
HXDLIN( 247)				Float r11 = r1->x;
HXDLIN( 247)				if ((r11 > (r2->x - e))) {
HXLINE( 247)					Float r12 = r1->x;
HXDLIN( 247)					_hx_tmp5 = (r12 < (r2->x + e));
            				}
            				else {
HXLINE( 247)					_hx_tmp5 = false;
            				}
HXDLIN( 247)				if (_hx_tmp5) {
HXLINE( 248)					Float r13 = r1->y;
HXLINE( 247)					_hx_tmp4 = (r13 > (r2->y - e));
            				}
            				else {
HXLINE( 247)					_hx_tmp4 = false;
            				}
HXDLIN( 247)				if (_hx_tmp4) {
HXLINE( 248)					Float r14 = r1->y;
HXLINE( 247)					_hx_tmp3 = (r14 < (r2->y + e));
            				}
            				else {
HXLINE( 247)					_hx_tmp3 = false;
            				}
HXDLIN( 247)				if (_hx_tmp3) {
HXLINE( 249)					Float r15 = r1->width;
HXLINE( 247)					_hx_tmp2 = (r15 > (r2->width - e));
            				}
            				else {
HXLINE( 247)					_hx_tmp2 = false;
            				}
HXDLIN( 247)				if (_hx_tmp2) {
HXLINE( 249)					Float r16 = r1->width;
HXLINE( 247)					_hx_tmp1 = (r16 < (r2->width + e));
            				}
            				else {
HXLINE( 247)					_hx_tmp1 = false;
            				}
HXDLIN( 247)				if (_hx_tmp1) {
HXLINE( 250)					Float r17 = r1->height;
HXLINE( 247)					_hx_tmp = (r17 > (r2->height - e));
            				}
            				else {
HXLINE( 247)					_hx_tmp = false;
            				}
HXDLIN( 247)				if (_hx_tmp) {
HXLINE( 250)					Float r18 = r1->height;
HXDLIN( 250)					return (r18 < (r2->height + e));
            				}
            				else {
HXLINE( 247)					return false;
            				}
            			}
            		}
HXLINE( 243)		return false;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(RectangleUtil_obj,compare,return )


RectangleUtil_obj::RectangleUtil_obj()
{
}

bool RectangleUtil_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"fit") ) { outValue = fit_dyn(); return true; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"sPoint") ) { outValue = ( sPoint ); return true; }
		if (HX_FIELD_EQ(inName,"extend") ) { outValue = extend_dyn(); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"compare") ) { outValue = compare_dyn(); return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"sPoint3D") ) { outValue = ( sPoint3D ); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"intersect") ) { outValue = intersect_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"normalize") ) { outValue = normalize_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"getBounds") ) { outValue = getBounds_dyn(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"sPositions") ) { outValue = ( sPositions ); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"getPositions") ) { outValue = getPositions_dyn(); return true; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"getBoundsProjected") ) { outValue = getBoundsProjected_dyn(); return true; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"extendToWholePixels") ) { outValue = extendToWholePixels_dyn(); return true; }
		break;
	case 23:
		if (HX_FIELD_EQ(inName,"nextSuitableScaleFactor") ) { outValue = nextSuitableScaleFactor_dyn(); return true; }
	}
	return false;
}

bool RectangleUtil_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"sPoint") ) { sPoint=ioValue.Cast<  ::openfl::geom::Point >(); return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"sPoint3D") ) { sPoint3D=ioValue.Cast<  ::openfl::geom::Vector3D >(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"sPositions") ) { sPositions=ioValue.Cast<  ::openfl::_Vector::AbstractVector >(); return true; }
	}
	return false;
}

#if HXCPP_SCRIPTABLE
static hx::StorageInfo *RectangleUtil_obj_sMemberStorageInfo = 0;
static hx::StaticInfo RectangleUtil_obj_sStaticStorageInfo[] = {
	{hx::fsObject /*::openfl::geom::Point*/ ,(void *) &RectangleUtil_obj::sPoint,HX_HCSTRING("sPoint","\xdd","\xa2","\xc7","\x54")},
	{hx::fsObject /*::openfl::geom::Vector3D*/ ,(void *) &RectangleUtil_obj::sPoint3D,HX_HCSTRING("sPoint3D","\xce","\x00","\x1c","\xd0")},
	{hx::fsObject /*::openfl::_Vector::AbstractVector*/ ,(void *) &RectangleUtil_obj::sPositions,HX_HCSTRING("sPositions","\xb7","\xac","\x98","\xd3")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static void RectangleUtil_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(RectangleUtil_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(RectangleUtil_obj::sPoint,"sPoint");
	HX_MARK_MEMBER_NAME(RectangleUtil_obj::sPoint3D,"sPoint3D");
	HX_MARK_MEMBER_NAME(RectangleUtil_obj::sPositions,"sPositions");
};

#ifdef HXCPP_VISIT_ALLOCS
static void RectangleUtil_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(RectangleUtil_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(RectangleUtil_obj::sPoint,"sPoint");
	HX_VISIT_MEMBER_NAME(RectangleUtil_obj::sPoint3D,"sPoint3D");
	HX_VISIT_MEMBER_NAME(RectangleUtil_obj::sPositions,"sPositions");
};

#endif

hx::Class RectangleUtil_obj::__mClass;

static ::String RectangleUtil_obj_sStaticFields[] = {
	HX_HCSTRING("sPoint","\xdd","\xa2","\xc7","\x54"),
	HX_HCSTRING("sPoint3D","\xce","\x00","\x1c","\xd0"),
	HX_HCSTRING("sPositions","\xb7","\xac","\x98","\xd3"),
	HX_HCSTRING("intersect","\xdf","\x00","\x75","\x42"),
	HX_HCSTRING("fit","\xd1","\xc1","\x4d","\x00"),
	HX_HCSTRING("nextSuitableScaleFactor","\xdf","\x5b","\x16","\xc5"),
	HX_HCSTRING("normalize","\x8d","\x37","\xa1","\xab"),
	HX_HCSTRING("extend","\xda","\xd1","\x1a","\xc7"),
	HX_HCSTRING("extendToWholePixels","\xcf","\x53","\x7b","\xa9"),
	HX_HCSTRING("getBounds","\xab","\x0f","\x74","\xe2"),
	HX_HCSTRING("getBoundsProjected","\x4d","\x96","\x9b","\x34"),
	HX_HCSTRING("getPositions","\x34","\x90","\xa8","\xdf"),
	HX_HCSTRING("compare","\xa5","\x18","\x69","\x83"),
	::String(null())
};

void RectangleUtil_obj::__register()
{
	hx::Object *dummy = new RectangleUtil_obj;
	RectangleUtil_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("starling.utils.RectangleUtil","\x0e","\x9a","\x54","\x66");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &RectangleUtil_obj::__GetStatic;
	__mClass->mSetStaticField = &RectangleUtil_obj::__SetStatic;
	__mClass->mMarkFunc = RectangleUtil_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(RectangleUtil_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = hx::TCanCast< RectangleUtil_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = RectangleUtil_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = RectangleUtil_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = RectangleUtil_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void RectangleUtil_obj::__boot()
{
{
            	HX_GC_STACKFRAME(&_hx_pos_2aa2a0cb645b21ab_25_boot)
HXDLIN(  25)		sPoint =  ::openfl::geom::Point_obj::__alloc( HX_CTX ,null(),null());
            	}
{
            	HX_GC_STACKFRAME(&_hx_pos_2aa2a0cb645b21ab_26_boot)
HXDLIN(  26)		sPoint3D =  ::openfl::geom::Vector3D_obj::__alloc( HX_CTX ,null(),null(),null(),null());
            	}
{
            		HX_BEGIN_LOCAL_FUNC_S0(hx::LocalFunc,_hx_Closure_0) HXARGC(0)
            		 ::Dynamic _hx_run(){
            			HX_GC_STACKFRAME(&_hx_pos_2aa2a0cb645b21ab_28_boot)
HXDLIN(  28)			 ::openfl::geom::Point a =  ::openfl::geom::Point_obj::__alloc( HX_CTX ,null(),null());
HXDLIN(  28)			 ::openfl::geom::Point a1 =  ::openfl::geom::Point_obj::__alloc( HX_CTX ,null(),null());
HXDLIN(  28)			 ::openfl::geom::Point a2 =  ::openfl::geom::Point_obj::__alloc( HX_CTX ,null(),null());
HXDLIN(  28)			::Array< ::Dynamic> a3 = ::Array_obj< ::Dynamic>::__new(4)->init(0,a)->init(1,a1)->init(2,a2)->init(3, ::openfl::geom::Point_obj::__alloc( HX_CTX ,null(),null()));
HXDLIN(  28)			int length = null();
HXDLIN(  28)			bool fixed = null();
HXDLIN(  28)			 ::openfl::_Vector::AbstractVector vector =  ::openfl::_Vector::AbstractVector_obj::__alloc( HX_CTX , ::openfl::_Vector::ObjectVector_obj::__alloc( HX_CTX ,length,fixed,null()),null());
HXDLIN(  28)			{
HXDLIN(  28)				int _g1 = (int)0;
HXDLIN(  28)				int _g = a3->length;
HXDLIN(  28)				while((_g1 < _g)){
HXDLIN(  28)					_g1 = (_g1 + (int)1);
HXDLIN(  28)					int i = (_g1 - (int)1);
HXDLIN(  28)					::openfl::_Vector::IVector_obj::set(vector->data,i,a3->__get(i).StaticCast<  ::openfl::geom::Point >());
            				}
            			}
HXDLIN(  28)			return vector;
            		}
            		HX_END_LOCAL_FUNC0(return)

            	HX_STACKFRAME(&_hx_pos_2aa2a0cb645b21ab_28_boot)
HXDLIN(  28)		sPositions =  ::Dynamic(new _hx_Closure_0())();
            	}
}

} // end namespace starling
} // end namespace utils
