// Generated by Haxe 3.4.4
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_haxegon_Geom
#include <haxegon/Geom.h>
#endif
#ifndef INCLUDED_openfl_geom_Rectangle
#include <openfl/geom/Rectangle.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_7f8acd3e2df07ab2_6_inbox,"haxegon.Geom","inbox",0x6926b102,"haxegon.Geom.inbox","haxegon/Geom.hx",6,0x66950df3)
HX_LOCAL_STACK_FRAME(_hx_pos_7f8acd3e2df07ab2_20_clamp,"haxegon.Geom","clamp",0xf36c04b7,"haxegon.Geom.clamp","haxegon/Geom.hx",20,0x66950df3)
HX_LOCAL_STACK_FRAME(_hx_pos_7f8acd3e2df07ab2_23_overlap,"haxegon.Geom","overlap",0xed78bc43,"haxegon.Geom.overlap","haxegon/Geom.hx",23,0x66950df3)
HX_LOCAL_STACK_FRAME(_hx_pos_7f8acd3e2df07ab2_31_distance,"haxegon.Geom","distance",0x02fabef9,"haxegon.Geom.distance","haxegon/Geom.hx",31,0x66950df3)
HX_LOCAL_STACK_FRAME(_hx_pos_7f8acd3e2df07ab2_35_getangle,"haxegon.Geom","getangle",0x868d0f41,"haxegon.Geom.getangle","haxegon/Geom.hx",35,0x66950df3)
HX_LOCAL_STACK_FRAME(_hx_pos_7f8acd3e2df07ab2_39_todegrees,"haxegon.Geom","todegrees",0x26a31348,"haxegon.Geom.todegrees","haxegon/Geom.hx",39,0x66950df3)
HX_LOCAL_STACK_FRAME(_hx_pos_7f8acd3e2df07ab2_43_toradians,"haxegon.Geom","toradians",0x13387613,"haxegon.Geom.toradians","haxegon/Geom.hx",43,0x66950df3)
HX_LOCAL_STACK_FRAME(_hx_pos_7f8acd3e2df07ab2_47_anglebetween,"haxegon.Geom","anglebetween",0x5d801c19,"haxegon.Geom.anglebetween","haxegon/Geom.hx",47,0x66950df3)
HX_LOCAL_STACK_FRAME(_hx_pos_7f8acd3e2df07ab2_50_boot,"haxegon.Geom","boot",0x3c227df6,"haxegon.Geom.boot","haxegon/Geom.hx",50,0x66950df3)
HX_LOCAL_STACK_FRAME(_hx_pos_7f8acd3e2df07ab2_51_boot,"haxegon.Geom","boot",0x3c227df6,"haxegon.Geom.boot","haxegon/Geom.hx",51,0x66950df3)
namespace haxegon{

void Geom_obj::__construct() { }

Dynamic Geom_obj::__CreateEmpty() { return new Geom_obj; }

void *Geom_obj::_hx_vtable = 0;

Dynamic Geom_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Geom_obj > _hx_result = new Geom_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Geom_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x0396daec;
}

bool Geom_obj::inbox(Float x,Float y,Float rectx,Float recty,Float rectw,Float recth){
            	HX_STACKFRAME(&_hx_pos_7f8acd3e2df07ab2_6_inbox)
HXLINE(   7)		if ((x >= rectx)) {
HXLINE(   8)			if ((x < (rectx + rectw))) {
HXLINE(   9)				if ((y >= recty)) {
HXLINE(  10)					if ((y < (recty + recth))) {
HXLINE(  11)						return true;
            					}
            				}
            			}
            		}
HXLINE(  16)		return false;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC6(Geom_obj,inbox,return )

Float Geom_obj::clamp(Float value,Float min,Float max){
            	HX_STACKFRAME(&_hx_pos_7f8acd3e2df07ab2_20_clamp)
HXDLIN(  20)		return ::Math_obj::min(max,::Math_obj::max(value,min));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Geom_obj,clamp,return )

bool Geom_obj::overlap(Float x1,Float y1,Float w1,Float h1,Float x2,Float y2,Float w2,Float h2){
            	HX_STACKFRAME(&_hx_pos_7f8acd3e2df07ab2_23_overlap)
HXLINE(  24)		::haxegon::Geom_obj::rect1->setTo(x1,y1,w1,h1);
HXLINE(  25)		::haxegon::Geom_obj::rect2->setTo(x2,y2,w2,h2);
HXLINE(  27)		return ::haxegon::Geom_obj::rect1->intersects(::haxegon::Geom_obj::rect2);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC8(Geom_obj,overlap,return )

Float Geom_obj::distance(Float x1,Float y1,Float x2,Float y2){
            	HX_STACKFRAME(&_hx_pos_7f8acd3e2df07ab2_31_distance)
HXDLIN(  31)		Float _hx_tmp = ::Math_obj::pow((x2 - x1),(int)2);
HXDLIN(  31)		return ::Math_obj::sqrt((_hx_tmp + ::Math_obj::pow((y2 - y1),(int)2)));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Geom_obj,distance,return )

Float Geom_obj::getangle(Float x1,Float y1,Float x2,Float y2){
            	HX_STACKFRAME(&_hx_pos_7f8acd3e2df07ab2_35_getangle)
HXDLIN(  35)		Float _hx_tmp = (::Math_obj::PI * (int)2);
HXDLIN(  35)		Float _hx_tmp1 = (_hx_tmp - ::Math_obj::atan2((y2 - y1),(x2 - x1)));
HXDLIN(  35)		return hx::Mod(_hx_tmp1,(::Math_obj::PI * (int)2));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Geom_obj,getangle,return )

Float Geom_obj::todegrees(Float rad){
            	HX_STACKFRAME(&_hx_pos_7f8acd3e2df07ab2_39_todegrees)
HXDLIN(  39)		return ((Float)(rad * (int)180) / (Float)::Math_obj::PI);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Geom_obj,todegrees,return )

Float Geom_obj::toradians(Float degrees){
            	HX_STACKFRAME(&_hx_pos_7f8acd3e2df07ab2_43_toradians)
HXDLIN(  43)		return ((Float)(degrees * ::Math_obj::PI) / (Float)(int)180);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Geom_obj,toradians,return )

Float Geom_obj::anglebetween(Float angle1,Float angle2){
            	HX_STACKFRAME(&_hx_pos_7f8acd3e2df07ab2_47_anglebetween)
HXDLIN(  47)		Float _hx_tmp = ::Math_obj::sin((angle1 - angle2));
HXDLIN(  47)		return -(::Math_obj::atan2(_hx_tmp,::Math_obj::cos((angle1 - angle2))));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Geom_obj,anglebetween,return )

 ::openfl::geom::Rectangle Geom_obj::rect1;

 ::openfl::geom::Rectangle Geom_obj::rect2;


Geom_obj::Geom_obj()
{
}

bool Geom_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"inbox") ) { outValue = inbox_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"clamp") ) { outValue = clamp_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"rect1") ) { outValue = ( rect1 ); return true; }
		if (HX_FIELD_EQ(inName,"rect2") ) { outValue = ( rect2 ); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"overlap") ) { outValue = overlap_dyn(); return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"distance") ) { outValue = distance_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"getangle") ) { outValue = getangle_dyn(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"todegrees") ) { outValue = todegrees_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"toradians") ) { outValue = toradians_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"anglebetween") ) { outValue = anglebetween_dyn(); return true; }
	}
	return false;
}

bool Geom_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"rect1") ) { rect1=ioValue.Cast<  ::openfl::geom::Rectangle >(); return true; }
		if (HX_FIELD_EQ(inName,"rect2") ) { rect2=ioValue.Cast<  ::openfl::geom::Rectangle >(); return true; }
	}
	return false;
}

#if HXCPP_SCRIPTABLE
static hx::StorageInfo *Geom_obj_sMemberStorageInfo = 0;
static hx::StaticInfo Geom_obj_sStaticStorageInfo[] = {
	{hx::fsObject /*::openfl::geom::Rectangle*/ ,(void *) &Geom_obj::rect1,HX_HCSTRING("rect1","\x8d","\x32","\xbc","\xe6")},
	{hx::fsObject /*::openfl::geom::Rectangle*/ ,(void *) &Geom_obj::rect2,HX_HCSTRING("rect2","\x8e","\x32","\xbc","\xe6")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static void Geom_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Geom_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(Geom_obj::rect1,"rect1");
	HX_MARK_MEMBER_NAME(Geom_obj::rect2,"rect2");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Geom_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Geom_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(Geom_obj::rect1,"rect1");
	HX_VISIT_MEMBER_NAME(Geom_obj::rect2,"rect2");
};

#endif

hx::Class Geom_obj::__mClass;

static ::String Geom_obj_sStaticFields[] = {
	HX_HCSTRING("inbox","\x46","\x1f","\x13","\xbe"),
	HX_HCSTRING("clamp","\xfb","\x72","\x58","\x48"),
	HX_HCSTRING("overlap","\x87","\x43","\x10","\xa9"),
	HX_HCSTRING("distance","\x35","\x93","\xf9","\x6b"),
	HX_HCSTRING("getangle","\x7d","\xe3","\x8b","\xef"),
	HX_HCSTRING("todegrees","\x8c","\xf3","\x9d","\x9c"),
	HX_HCSTRING("toradians","\x57","\x56","\x33","\x89"),
	HX_HCSTRING("anglebetween","\x55","\xbe","\x83","\x9c"),
	HX_HCSTRING("rect1","\x8d","\x32","\xbc","\xe6"),
	HX_HCSTRING("rect2","\x8e","\x32","\xbc","\xe6"),
	::String(null())
};

void Geom_obj::__register()
{
	hx::Object *dummy = new Geom_obj;
	Geom_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("haxegon.Geom","\x2a","\xbd","\x37","\x98");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Geom_obj::__GetStatic;
	__mClass->mSetStaticField = &Geom_obj::__SetStatic;
	__mClass->mMarkFunc = Geom_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(Geom_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = hx::TCanCast< Geom_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Geom_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Geom_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Geom_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void Geom_obj::__boot()
{
{
            	HX_GC_STACKFRAME(&_hx_pos_7f8acd3e2df07ab2_50_boot)
HXDLIN(  50)		rect1 =  ::openfl::geom::Rectangle_obj::__alloc( HX_CTX ,null(),null(),null(),null());
            	}
{
            	HX_GC_STACKFRAME(&_hx_pos_7f8acd3e2df07ab2_51_boot)
HXDLIN(  51)		rect2 =  ::openfl::geom::Rectangle_obj::__alloc( HX_CTX ,null(),null(),null(),null());
            	}
}

} // end namespace haxegon
