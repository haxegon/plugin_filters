// Generated by Haxe 3.4.4
#include <hxcpp.h>

#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_Xml
#include <Xml.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_haxegon_Data
#include <haxegon/Data.h>
#endif
#ifndef INCLUDED_haxegon_Debug
#include <haxegon/Debug.h>
#endif
#ifndef INCLUDED_haxegon_Fontfile
#include <haxegon/Fontfile.h>
#endif
#ifndef INCLUDED_haxegon_Gfx
#include <haxegon/Gfx.h>
#endif
#ifndef INCLUDED_haxegon_embeddedassets_DefaultFont
#include <haxegon/embeddedassets/DefaultFont.h>
#endif
#ifndef INCLUDED_lime_text_Font
#include <lime/text/Font.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_text_Font
#include <openfl/text/Font.h>
#endif
#ifndef INCLUDED_starling_display_DisplayObject
#include <starling/display/DisplayObject.h>
#endif
#ifndef INCLUDED_starling_display_DisplayObjectContainer
#include <starling/display/DisplayObjectContainer.h>
#endif
#ifndef INCLUDED_starling_events_EventDispatcher
#include <starling/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_starling_text_BitmapFont
#include <starling/text/BitmapFont.h>
#endif
#ifndef INCLUDED_starling_text_ITextCompositor
#include <starling/text/ITextCompositor.h>
#endif
#ifndef INCLUDED_starling_text_TextField
#include <starling/text/TextField.h>
#endif
#ifndef INCLUDED_starling_textures_Texture
#include <starling/textures/Texture.h>
#endif
#ifndef INCLUDED_starling_utils_AssetManager
#include <starling/utils/AssetManager.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_8415dbc839f39353_84_new,"haxegon.Fontfile","new",0x15be7eab,"haxegon.Fontfile.new","haxegon/Text.hx",84,0xb667cca2)
namespace haxegon{

void Fontfile_obj::__construct(::String _file){
            	HX_GC_STACKFRAME(&_hx_pos_8415dbc839f39353_84_new)
HXDLIN(  84)		if (hx::IsNull( _file )) {
HXLINE(  85)			this->type = HX_("bitmap",ef,0f,0c,f1);
HXLINE(  87)			this->fontxml = ::Xml_obj::parse(::haxegon::embeddedassets::DefaultFont_obj::get_xmlstring())->firstElement();
HXLINE(  88)			this->_hx_typename = ( ( ::Xml)(this->fontxml->elementsNamed(HX_("info",6e,38,bb,45))->__Field(HX_("next",f3,84,02,49),hx::paccDynamic)()) )->get(HX_("face",9d,b4,b5,43));
HXLINE(  89)			this->sizescale = ::Std_obj::parseInt(( ( ::Xml)(this->fontxml->elementsNamed(HX_("info",6e,38,bb,45))->__Field(HX_("next",f3,84,02,49),hx::paccDynamic)()) )->get(HX_("size",c1,a0,53,4c)));
HXLINE(  90)			this->fonttex = ::starling::textures::Texture_obj::fromBitmapData(::haxegon::embeddedassets::DefaultFont_obj::get_bitmapdata(),false,null(),null(),null(),null(),null());
HXLINE(  91)			this->bitmapfont =  ::starling::text::BitmapFont_obj::__alloc( HX_CTX ,this->fonttex,this->fontxml);
HXLINE(  92)			 ::starling::text::BitmapFont _hx_tmp = this->bitmapfont;
HXDLIN(  92)			::starling::text::TextField_obj::registerCompositor(_hx_tmp,this->bitmapfont->get_name());
HXLINE(  94)			this->filename = HX_("",00,00,00,00);
HXLINE(  95)			this->_hx_typename = HX_("default",c1,d8,c3,9b);
HXLINE(  96)			this->sizescale = ::Std_obj::parseInt(( ( ::Xml)(this->fontxml->elementsNamed(HX_("info",6e,38,bb,45))->__Field(HX_("next",f3,84,02,49),hx::paccDynamic)()) )->get(HX_("size",c1,a0,53,4c)));
            		}
            		else {
HXLINE(  97)			if (::haxegon::Data_obj::assetexists(((HX_("data/fonts/",70,04,fa,11) + _file) + HX_(".fnt",be,96,b5,1e)))) {
HXLINE(  98)				this->type = HX_("bitmap",ef,0f,0c,f1);
HXLINE( 100)				::String fontdata = ::haxegon::Data_obj::gettextasset(((HX_("data/fonts/",70,04,fa,11) + _file) + HX_(".fnt",be,96,b5,1e)));
HXLINE( 101)				this->fontxml = ::Xml_obj::parse(fontdata)->firstElement();
HXLINE( 102)				this->_hx_typename = ( ( ::Xml)(this->fontxml->elementsNamed(HX_("info",6e,38,bb,45))->__Field(HX_("next",f3,84,02,49),hx::paccDynamic)()) )->get(HX_("face",9d,b4,b5,43));
HXLINE( 103)				this->pngname = ( ( ::Xml)(( ( ::Xml)(::Xml_obj::parse(fontdata)->firstElement()->elementsNamed(HX_("pages",44,2b,4d,bd))->__Field(HX_("next",f3,84,02,49),hx::paccDynamic)()) )->elementsNamed(HX_("page",4f,da,51,4a))->__Field(HX_("next",f3,84,02,49),hx::paccDynamic)()) )->get(HX_("file",7c,ce,bb,43));
HXLINE( 105)				if (hx::IsNull( this->pngname )) {
HXLINE( 106)					::haxegon::Debug_obj::log(((HX_("ERROR: Bitmap font XML file \"",35,64,94,1b) + _file) + HX_(".fnt\" does not reference a .png file.",59,c7,8d,b0)),hx::SourceInfo(HX_("Text.hx",11,08,fc,6b),106,HX_("haxegon.Fontfile",39,4d,01,b6),HX_("new",60,d0,53,00)));
            				}
HXLINE( 108)				::String currentstring = this->pngname;
HXDLIN( 108)				if ((currentstring.substr((currentstring.length - (int)4),(int)4) == HX_(".png",3b,2d,bd,1e))) {
HXLINE( 109)					this->pngname = this->pngname.substr((int)0,(this->pngname.length - (int)4));
            				}
HXLINE( 111)				this->sizescale = ::Std_obj::parseInt(( ( ::Xml)(this->fontxml->elementsNamed(HX_("info",6e,38,bb,45))->__Field(HX_("next",f3,84,02,49),hx::paccDynamic)()) )->get(HX_("size",c1,a0,53,4c)));
HXLINE( 113)				if (::haxegon::Gfx_obj::imageindex->exists((HX_("fonts/",eb,13,ef,fa) + this->pngname))) {
HXLINE( 115)					 ::starling::utils::AssetManager _hx_tmp1 = ::haxegon::Gfx_obj::starlingassets;
HXDLIN( 115)					this->fonttex = _hx_tmp1->getTexture((HX_("fonts/",eb,13,ef,fa) + this->pngname));
            				}
            				else {
HXLINE( 117)					this->fonttex = ::starling::textures::Texture_obj::fromBitmapData(::haxegon::Data_obj::getgraphicsasset(((HX_("data/fonts/",70,04,fa,11) + this->pngname) + HX_(".png",3b,2d,bd,1e))),false,null(),null(),null(),null(),null());
            				}
HXLINE( 119)				this->bitmapfont =  ::starling::text::BitmapFont_obj::__alloc( HX_CTX ,this->fonttex,this->fontxml);
HXLINE( 120)				 ::starling::text::BitmapFont _hx_tmp2 = this->bitmapfont;
HXDLIN( 120)				::starling::text::TextField_obj::registerCompositor(_hx_tmp2,this->bitmapfont->get_name());
            			}
            			else {
HXLINE( 122)				this->type = HX_("ttf",e6,6a,58,00);
HXLINE( 124)				this->filename = ((HX_("data/fonts/",70,04,fa,11) + _file) + HX_(".ttf",78,3b,c0,1e));
HXLINE( 125)				try {
            					HX_STACK_CATCHABLE( ::Dynamic, 0);
HXLINE( 126)					this->font = ::haxegon::Data_obj::getfontasset(this->filename);
HXLINE( 127)					this->_hx_typename = this->font->name;
            				}
            				catch( ::Dynamic _hx_e){
            					if (_hx_e.IsClass<  ::Dynamic >() ){
            						HX_STACK_BEGIN_CATCH
            						 ::Dynamic e = _hx_e;
HXLINE( 129)						::haxegon::Debug_obj::log(((HX_("ERROR: Cannot set font to \"",c1,01,19,8a) + _file) + HX_("\", no TTF or Bitmap Font found.",a6,55,f4,68)),hx::SourceInfo(HX_("Text.hx",11,08,fc,6b),129,HX_("haxegon.Fontfile",39,4d,01,b6),HX_("new",60,d0,53,00)));
            					}
            					else {
            						HX_STACK_DO_THROW(_hx_e);
            					}
            				}
HXLINE( 131)				this->sizescale = (int)1;
            			}
            		}
            	}

Dynamic Fontfile_obj::__CreateEmpty() { return new Fontfile_obj; }

void *Fontfile_obj::_hx_vtable = 0;

Dynamic Fontfile_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Fontfile_obj > _hx_result = new Fontfile_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

bool Fontfile_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x534a378b;
}


hx::ObjectPtr< Fontfile_obj > Fontfile_obj::__new(::String _file) {
	hx::ObjectPtr< Fontfile_obj > __this = new Fontfile_obj();
	__this->__construct(_file);
	return __this;
}

hx::ObjectPtr< Fontfile_obj > Fontfile_obj::__alloc(hx::Ctx *_hx_ctx,::String _file) {
	Fontfile_obj *__this = (Fontfile_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(Fontfile_obj), true, "haxegon.Fontfile"));
	*(void **)__this = Fontfile_obj::_hx_vtable;
	__this->__construct(_file);
	return __this;
}

Fontfile_obj::Fontfile_obj()
{
}

void Fontfile_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Fontfile);
	HX_MARK_MEMBER_NAME(_hx_typename,"typename");
	HX_MARK_MEMBER_NAME(bitmapfont,"bitmapfont");
	HX_MARK_MEMBER_NAME(fontxml,"fontxml");
	HX_MARK_MEMBER_NAME(fonttex,"fonttex");
	HX_MARK_MEMBER_NAME(pngname,"pngname");
	HX_MARK_MEMBER_NAME(sizescale,"sizescale");
	HX_MARK_MEMBER_NAME(font,"font");
	HX_MARK_MEMBER_NAME(filename,"filename");
	HX_MARK_MEMBER_NAME(type,"type");
	HX_MARK_END_CLASS();
}

void Fontfile_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(_hx_typename,"typename");
	HX_VISIT_MEMBER_NAME(bitmapfont,"bitmapfont");
	HX_VISIT_MEMBER_NAME(fontxml,"fontxml");
	HX_VISIT_MEMBER_NAME(fonttex,"fonttex");
	HX_VISIT_MEMBER_NAME(pngname,"pngname");
	HX_VISIT_MEMBER_NAME(sizescale,"sizescale");
	HX_VISIT_MEMBER_NAME(font,"font");
	HX_VISIT_MEMBER_NAME(filename,"filename");
	HX_VISIT_MEMBER_NAME(type,"type");
}

hx::Val Fontfile_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"font") ) { return hx::Val( font ); }
		if (HX_FIELD_EQ(inName,"type") ) { return hx::Val( type ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"fontxml") ) { return hx::Val( fontxml ); }
		if (HX_FIELD_EQ(inName,"fonttex") ) { return hx::Val( fonttex ); }
		if (HX_FIELD_EQ(inName,"pngname") ) { return hx::Val( pngname ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"typename") ) { return hx::Val( _hx_typename ); }
		if (HX_FIELD_EQ(inName,"filename") ) { return hx::Val( filename ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"sizescale") ) { return hx::Val( sizescale ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"bitmapfont") ) { return hx::Val( bitmapfont ); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val Fontfile_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"font") ) { font=inValue.Cast<  ::openfl::text::Font >(); return inValue; }
		if (HX_FIELD_EQ(inName,"type") ) { type=inValue.Cast< ::String >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"fontxml") ) { fontxml=inValue.Cast<  ::Xml >(); return inValue; }
		if (HX_FIELD_EQ(inName,"fonttex") ) { fonttex=inValue.Cast<  ::starling::textures::Texture >(); return inValue; }
		if (HX_FIELD_EQ(inName,"pngname") ) { pngname=inValue.Cast< ::String >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"typename") ) { _hx_typename=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"filename") ) { filename=inValue.Cast< ::String >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"sizescale") ) { sizescale=inValue.Cast< int >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"bitmapfont") ) { bitmapfont=inValue.Cast<  ::starling::text::BitmapFont >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Fontfile_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("typename","\x05","\x4a","\xf1","\xca"));
	outFields->push(HX_HCSTRING("bitmapfont","\x3e","\x91","\x44","\x4a"));
	outFields->push(HX_HCSTRING("fontxml","\x68","\x5b","\x46","\x96"));
	outFields->push(HX_HCSTRING("fonttex","\x78","\x4b","\x43","\x96"));
	outFields->push(HX_HCSTRING("pngname","\x74","\xd7","\xea","\xc3"));
	outFields->push(HX_HCSTRING("sizescale","\x29","\xd2","\x37","\xe4"));
	outFields->push(HX_HCSTRING("font","\xcf","\x5d","\xc0","\x43"));
	outFields->push(HX_HCSTRING("filename","\xc7","\x2e","\x6a","\x77"));
	outFields->push(HX_HCSTRING("type","\xba","\xf2","\x08","\x4d"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo Fontfile_obj_sMemberStorageInfo[] = {
	{hx::fsString,(int)offsetof(Fontfile_obj,_hx_typename),HX_HCSTRING("typename","\x05","\x4a","\xf1","\xca")},
	{hx::fsObject /*::starling::text::BitmapFont*/ ,(int)offsetof(Fontfile_obj,bitmapfont),HX_HCSTRING("bitmapfont","\x3e","\x91","\x44","\x4a")},
	{hx::fsObject /*::Xml*/ ,(int)offsetof(Fontfile_obj,fontxml),HX_HCSTRING("fontxml","\x68","\x5b","\x46","\x96")},
	{hx::fsObject /*::starling::textures::Texture*/ ,(int)offsetof(Fontfile_obj,fonttex),HX_HCSTRING("fonttex","\x78","\x4b","\x43","\x96")},
	{hx::fsString,(int)offsetof(Fontfile_obj,pngname),HX_HCSTRING("pngname","\x74","\xd7","\xea","\xc3")},
	{hx::fsInt,(int)offsetof(Fontfile_obj,sizescale),HX_HCSTRING("sizescale","\x29","\xd2","\x37","\xe4")},
	{hx::fsObject /*::openfl::text::Font*/ ,(int)offsetof(Fontfile_obj,font),HX_HCSTRING("font","\xcf","\x5d","\xc0","\x43")},
	{hx::fsString,(int)offsetof(Fontfile_obj,filename),HX_HCSTRING("filename","\xc7","\x2e","\x6a","\x77")},
	{hx::fsString,(int)offsetof(Fontfile_obj,type),HX_HCSTRING("type","\xba","\xf2","\x08","\x4d")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *Fontfile_obj_sStaticStorageInfo = 0;
#endif

static ::String Fontfile_obj_sMemberFields[] = {
	HX_HCSTRING("typename","\x05","\x4a","\xf1","\xca"),
	HX_HCSTRING("bitmapfont","\x3e","\x91","\x44","\x4a"),
	HX_HCSTRING("fontxml","\x68","\x5b","\x46","\x96"),
	HX_HCSTRING("fonttex","\x78","\x4b","\x43","\x96"),
	HX_HCSTRING("pngname","\x74","\xd7","\xea","\xc3"),
	HX_HCSTRING("sizescale","\x29","\xd2","\x37","\xe4"),
	HX_HCSTRING("font","\xcf","\x5d","\xc0","\x43"),
	HX_HCSTRING("filename","\xc7","\x2e","\x6a","\x77"),
	HX_HCSTRING("type","\xba","\xf2","\x08","\x4d"),
	::String(null()) };

static void Fontfile_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Fontfile_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Fontfile_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Fontfile_obj::__mClass,"__mClass");
};

#endif

hx::Class Fontfile_obj::__mClass;

void Fontfile_obj::__register()
{
	hx::Object *dummy = new Fontfile_obj;
	Fontfile_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("haxegon.Fontfile","\x39","\x4d","\x01","\xb6");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = Fontfile_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(Fontfile_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< Fontfile_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Fontfile_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Fontfile_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Fontfile_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace haxegon
