// Generated by Haxe 3.4.4
#include <hxcpp.h>

#ifndef INCLUDED_haxegon_filters_BloomEffect
#include <haxegon/filters/BloomEffect.h>
#endif
#ifndef INCLUDED_openfl__Vector_AbstractVector
#include <openfl/_Vector/AbstractVector.h>
#endif
#ifndef INCLUDED_openfl__Vector_FloatVector
#include <openfl/_Vector/FloatVector.h>
#endif
#ifndef INCLUDED_openfl__Vector_IVector
#include <openfl/_Vector/IVector.h>
#endif
#ifndef INCLUDED_openfl_display3D_Context3D
#include <openfl/display3D/Context3D.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_starling_rendering_Effect
#include <starling/rendering/Effect.h>
#endif
#ifndef INCLUDED_starling_rendering_FilterEffect
#include <starling/rendering/FilterEffect.h>
#endif
#ifndef INCLUDED_starling_rendering_Program
#include <starling/rendering/Program.h>
#endif
#ifndef INCLUDED_starling_textures_Texture
#include <starling/textures/Texture.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_07d765c093809420_110_new,"haxegon.filters.BloomEffect","new",0x36335745,"haxegon.filters.BloomEffect.new","haxegon/filters/Bloomfilter.hx",110,0x12c42da6)
static const Float _hx_array_data_ce0350d3_4[] = {
	(Float)0,(Float)0,(Float)0,2.5,
};
static const Float _hx_array_data_ce0350d3_5[] = {
	-1.0,0.0,1.0,9.0,
};
static const Float _hx_array_data_ce0350d3_6[] = {
	1.0,1.0,1.0,1.0,
};
HX_LOCAL_STACK_FRAME(_hx_pos_07d765c093809420_125_createProgram,"haxegon.filters.BloomEffect","createProgram",0x71f51a0d,"haxegon.filters.BloomEffect.createProgram","haxegon/filters/Bloomfilter.hx",125,0x12c42da6)
HX_LOCAL_STACK_FRAME(_hx_pos_07d765c093809420_218_beforeDraw,"haxegon.filters.BloomEffect","beforeDraw",0xf6f6a7de,"haxegon.filters.BloomEffect.beforeDraw","haxegon/filters/Bloomfilter.hx",218,0x12c42da6)
namespace haxegon{
namespace filters{

void BloomEffect_obj::__construct(hx::Null< Float >  __o__blur,hx::Null< Float >  __o__red,hx::Null< Float >  __o__green,hx::Null< Float >  __o__blue,hx::Null< int >  __o_numPasses){
Float _blur = __o__blur.Default(2);
Float _red = __o__red.Default(1);
Float _green = __o__green.Default(1);
Float _blue = __o__blue.Default(1);
int numPasses = __o_numPasses.Default(1);
            	HX_GC_STACKFRAME(&_hx_pos_07d765c093809420_110_new)
HXLINE( 111)		super::__construct();
HXLINE( 113)		this->blur = _blur;
HXLINE( 114)		this->red = _red;
HXLINE( 115)		this->green = _green;
HXLINE( 116)		this->blue = _blue;
HXLINE( 120)		::Array< Float > a = ::Array_obj< Float >::fromData( _hx_array_data_ce0350d3_4,4);
HXDLIN( 120)		int length = null();
HXDLIN( 120)		bool fixed = null();
HXDLIN( 120)		 ::openfl::_Vector::AbstractVector vector =  ::openfl::_Vector::AbstractVector_obj::__alloc( HX_CTX , ::openfl::_Vector::FloatVector_obj::__alloc( HX_CTX ,length,fixed,null()),null());
HXDLIN( 120)		{
HXLINE( 120)			int _g1 = (int)0;
HXDLIN( 120)			int _g = a->length;
HXDLIN( 120)			while((_g1 < _g)){
HXLINE( 120)				_g1 = (_g1 + (int)1);
HXDLIN( 120)				int i = (_g1 - (int)1);
HXDLIN( 120)				::openfl::_Vector::IVector_obj::set(vector->data,i,a->__get(i));
            			}
            		}
HXDLIN( 120)		this->fc0 = vector;
HXLINE( 121)		::Array< Float > a1 = ::Array_obj< Float >::fromData( _hx_array_data_ce0350d3_5,4);
HXDLIN( 121)		int length1 = null();
HXDLIN( 121)		bool fixed1 = null();
HXDLIN( 121)		 ::openfl::_Vector::AbstractVector vector1 =  ::openfl::_Vector::AbstractVector_obj::__alloc( HX_CTX , ::openfl::_Vector::FloatVector_obj::__alloc( HX_CTX ,length1,fixed1,null()),null());
HXDLIN( 121)		{
HXLINE( 121)			int _g11 = (int)0;
HXDLIN( 121)			int _g2 = a1->length;
HXDLIN( 121)			while((_g11 < _g2)){
HXLINE( 121)				_g11 = (_g11 + (int)1);
HXDLIN( 121)				int i1 = (_g11 - (int)1);
HXDLIN( 121)				::openfl::_Vector::IVector_obj::set(vector1->data,i1,a1->__get(i1));
            			}
            		}
HXDLIN( 121)		this->fc1 = vector1;
HXLINE( 122)		::Array< Float > a2 = ::Array_obj< Float >::fromData( _hx_array_data_ce0350d3_6,4);
HXDLIN( 122)		int length2 = null();
HXDLIN( 122)		bool fixed2 = null();
HXDLIN( 122)		 ::openfl::_Vector::AbstractVector vector2 =  ::openfl::_Vector::AbstractVector_obj::__alloc( HX_CTX , ::openfl::_Vector::FloatVector_obj::__alloc( HX_CTX ,length2,fixed2,null()),null());
HXDLIN( 122)		{
HXLINE( 122)			int _g12 = (int)0;
HXDLIN( 122)			int _g3 = a2->length;
HXDLIN( 122)			while((_g12 < _g3)){
HXLINE( 122)				_g12 = (_g12 + (int)1);
HXDLIN( 122)				int i2 = (_g12 - (int)1);
HXDLIN( 122)				::openfl::_Vector::IVector_obj::set(vector2->data,i2,a2->__get(i2));
            			}
            		}
HXDLIN( 122)		this->_color = vector2;
            	}

Dynamic BloomEffect_obj::__CreateEmpty() { return new BloomEffect_obj; }

void *BloomEffect_obj::_hx_vtable = 0;

Dynamic BloomEffect_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< BloomEffect_obj > _hx_result = new BloomEffect_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3],inArgs[4]);
	return _hx_result;
}

bool BloomEffect_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x1bd0cc2d) {
		if (inClassId<=(int)0x15407461) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x15407461;
		} else {
			return inClassId==(int)0x1bd0cc2d;
		}
	} else {
		return inClassId==(int)0x2a6d1e35;
	}
}

 ::starling::rendering::Program BloomEffect_obj::createProgram(){
            	HX_STACKFRAME(&_hx_pos_07d765c093809420_125_createProgram)
HXLINE( 126)		::String vertexShader = ::starling::rendering::FilterEffect_obj::STD_VERTEX_SHADER;
HXLINE( 127)		::String fragmentShader = (((((((((((((((((((((((((((((((((((((((((((((((((((((((HX_("tex ft0, v0, fs0<2d, clamp, linear, mipnone>  \n",1a,94,fd,65) + HX_("mov ft1, fc0.xxxx  \n",c4,16,97,63)) + HX_("mov ft2.x, fc0.y  \n",82,62,dd,14)) + HX_("mul ft2.x, ft2.x, fc0.w  \n",ca,e2,bc,62)) + HX_("div ft2.x, fc1.z, ft2.x  \n",fd,ec,dd,47)) + HX_("mov ft2.y, fc0.z  \n",62,04,65,96)) + HX_("mul ft2.y, ft2.y, fc0.w  \n",ea,3c,ff,f5)) + HX_("div ft2.y, fc1.z, ft2.y  \n",7b,12,eb,5a)) + HX_("mov ft3.xy, fc1.xx  \n",c6,4b,d8,25)) + HX_("mul ft3.xy, ft3.xy, ft2.xy  \n",07,c1,20,be)) + HX_("add ft3.xy, ft3.xy, v0.xy  \n",50,e2,53,62)) + HX_("tex ft4, ft3.xy, fs0<2d, clamp, linear, mipnone>  \n",4e,88,92,0e)) + HX_("add ft1, ft1, ft4  \n",23,0a,6d,41)) + HX_("mov ft3.xy, fc1.xy  \n",65,82,81,26)) + HX_("mul ft3.xy, ft3.xy, ft2.xy  \n",07,c1,20,be)) + HX_("add ft3.xy, ft3.xy, v0.xy  \n",50,e2,53,62)) + HX_("tex ft4, ft3.xy, fs0<2d, clamp, linear, mipnone>  \n",4e,88,92,0e)) + HX_("add ft1, ft1, ft4  \n",23,0a,6d,41)) + HX_("mov ft3.xy, fc1.xz  \n",04,b9,2a,27)) + HX_("mul ft3.xy, ft3.xy, ft2.xy  \n",07,c1,20,be)) + HX_("add ft3.xy, ft3.xy, v0.xy  \n",50,e2,53,62)) + HX_("tex ft4, ft3.xy, fs0<2d, clamp, linear, mipnone>  \n",4e,88,92,0e)) + HX_("add ft1, ft1, ft4  \n",23,0a,6d,41)) + HX_("mov ft3.xy, fc1.yx  \n",47,e0,3e,b9)) + HX_("mul ft3.xy, ft3.xy, ft2.xy  \n",07,c1,20,be)) + HX_("add ft3.xy, ft3.xy, v0.xy  \n",50,e2,53,62)) + HX_("tex ft4, ft3.xy, fs0<2d, clamp, linear, mipnone>  \n",4e,88,92,0e)) + HX_("add ft1, ft1, ft4  \n",23,0a,6d,41)) + HX_("mov ft3.xy, fc1.yy  \n",e6,16,e8,b9)) + HX_("mul ft3.xy, ft3.xy, ft2.xy  \n",07,c1,20,be)) + HX_("add ft3.xy, ft3.xy, v0.xy  \n",50,e2,53,62)) + HX_("tex ft4, ft3.xy, fs0<2d, clamp, linear, mipnone>  \n",4e,88,92,0e)) + HX_("add ft1, ft1, ft4  \n",23,0a,6d,41)) + HX_("mov ft3.xy, fc1.yz  \n",85,4d,91,ba)) + HX_("mul ft3.xy, ft3.xy, ft2.xy  \n",07,c1,20,be)) + HX_("add ft3.xy, ft3.xy, v0.xy  \n",50,e2,53,62)) + HX_("tex ft4, ft3.xy, fs0<2d, clamp, linear, mipnone>  \n",4e,88,92,0e)) + HX_("add ft1, ft1, ft4  \n",23,0a,6d,41)) + HX_("mov ft3.xy, fc1.zx  \n",c8,74,a5,4c)) + HX_("mul ft3.xy, ft3.xy, ft2.xy  \n",07,c1,20,be)) + HX_("add ft3.xy, ft3.xy, v0.xy  \n",50,e2,53,62)) + HX_("tex ft4, ft3.xy, fs0<2d, clamp, linear, mipnone>  \n",4e,88,92,0e)) + HX_("add ft1, ft1, ft4  \n",23,0a,6d,41)) + HX_("mov ft3.xy, fc1.zy  \n",67,ab,4e,4d)) + HX_("mul ft3.xy, ft3.xy, ft2.xy  \n",07,c1,20,be)) + HX_("add ft3.xy, ft3.xy, v0.xy  \n",50,e2,53,62)) + HX_("tex ft4, ft3.xy, fs0<2d, clamp, linear, mipnone>  \n",4e,88,92,0e)) + HX_("add ft1, ft1, ft4  \n",23,0a,6d,41)) + HX_("mov ft3.xy, fc1.zz  \n",06,e2,f7,4d)) + HX_("mul ft3.xy, ft3.xy, ft2.xy  \n",07,c1,20,be)) + HX_("add ft3.xy, ft3.xy, v0.xy  \n",50,e2,53,62)) + HX_("tex ft4, ft3.xy, fs0<2d, clamp, linear, mipnone>  \n",4e,88,92,0e)) + HX_("add ft1, ft1, ft4  \n",23,0a,6d,41)) + HX_("div ft1, ft1, fc1.wwww  \n",01,13,82,ec)) + HX_("add ft1, ft1, ft0  \n",a7,2f,c8,3e)) + HX_("mul oc, ft1, fc2",82,2a,14,27));
HXLINE( 215)		return ::starling::rendering::Program_obj::fromSource(vertexShader,fragmentShader,null());
            	}


void BloomEffect_obj::beforeDraw( ::openfl::display3D::Context3D context){
            	HX_STACKFRAME(&_hx_pos_07d765c093809420_218_beforeDraw)
HXLINE( 219)		{
HXLINE( 219)			 ::openfl::_Vector::AbstractVector this1 = this->fc0;
HXDLIN( 219)			Float value = this->get_texture()->get_width();
HXDLIN( 219)			::openfl::_Vector::IVector_obj::set(this1->data,(int)1,value);
            		}
HXLINE( 220)		{
HXLINE( 220)			 ::openfl::_Vector::AbstractVector this2 = this->fc0;
HXDLIN( 220)			Float value1 = this->get_texture()->get_height();
HXDLIN( 220)			::openfl::_Vector::IVector_obj::set(this2->data,(int)2,value1);
            		}
HXLINE( 221)		::openfl::_Vector::IVector_obj::set(this->fc0->data,(int)3,((Float)(int)1 / (Float)this->blur));
HXLINE( 223)		::openfl::_Vector::IVector_obj::set(this->_color->data,(int)0,this->red);
HXLINE( 224)		::openfl::_Vector::IVector_obj::set(this->_color->data,(int)1,this->green);
HXLINE( 225)		::openfl::_Vector::IVector_obj::set(this->_color->data,(int)2,this->blue);
HXLINE( 227)		this->super::beforeDraw(context);
HXLINE( 229)		context->setProgramConstantsFromVector((int)0,(int)0,this->fc0,null());
HXLINE( 230)		context->setProgramConstantsFromVector((int)0,(int)1,this->fc1,null());
HXLINE( 231)		context->setProgramConstantsFromVector((int)0,(int)2,this->_color,null());
            	}



hx::ObjectPtr< BloomEffect_obj > BloomEffect_obj::__new(hx::Null< Float >  __o__blur,hx::Null< Float >  __o__red,hx::Null< Float >  __o__green,hx::Null< Float >  __o__blue,hx::Null< int >  __o_numPasses) {
	hx::ObjectPtr< BloomEffect_obj > __this = new BloomEffect_obj();
	__this->__construct(__o__blur,__o__red,__o__green,__o__blue,__o_numPasses);
	return __this;
}

hx::ObjectPtr< BloomEffect_obj > BloomEffect_obj::__alloc(hx::Ctx *_hx_ctx,hx::Null< Float >  __o__blur,hx::Null< Float >  __o__red,hx::Null< Float >  __o__green,hx::Null< Float >  __o__blue,hx::Null< int >  __o_numPasses) {
	BloomEffect_obj *__this = (BloomEffect_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(BloomEffect_obj), true, "haxegon.filters.BloomEffect"));
	*(void **)__this = BloomEffect_obj::_hx_vtable;
	__this->__construct(__o__blur,__o__red,__o__green,__o__blue,__o_numPasses);
	return __this;
}

BloomEffect_obj::BloomEffect_obj()
{
}

void BloomEffect_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(BloomEffect);
	HX_MARK_MEMBER_NAME(fc0,"fc0");
	HX_MARK_MEMBER_NAME(fc1,"fc1");
	HX_MARK_MEMBER_NAME(_color,"_color");
	HX_MARK_MEMBER_NAME(red,"red");
	HX_MARK_MEMBER_NAME(green,"green");
	HX_MARK_MEMBER_NAME(blue,"blue");
	HX_MARK_MEMBER_NAME(blur,"blur");
	 ::starling::rendering::FilterEffect_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void BloomEffect_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(fc0,"fc0");
	HX_VISIT_MEMBER_NAME(fc1,"fc1");
	HX_VISIT_MEMBER_NAME(_color,"_color");
	HX_VISIT_MEMBER_NAME(red,"red");
	HX_VISIT_MEMBER_NAME(green,"green");
	HX_VISIT_MEMBER_NAME(blue,"blue");
	HX_VISIT_MEMBER_NAME(blur,"blur");
	 ::starling::rendering::FilterEffect_obj::__Visit(HX_VISIT_ARG);
}

hx::Val BloomEffect_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"fc0") ) { return hx::Val( fc0 ); }
		if (HX_FIELD_EQ(inName,"fc1") ) { return hx::Val( fc1 ); }
		if (HX_FIELD_EQ(inName,"red") ) { return hx::Val( red ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"blue") ) { return hx::Val( blue ); }
		if (HX_FIELD_EQ(inName,"blur") ) { return hx::Val( blur ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"green") ) { return hx::Val( green ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"_color") ) { return hx::Val( _color ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"beforeDraw") ) { return hx::Val( beforeDraw_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"createProgram") ) { return hx::Val( createProgram_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val BloomEffect_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"fc0") ) { fc0=inValue.Cast<  ::openfl::_Vector::AbstractVector >(); return inValue; }
		if (HX_FIELD_EQ(inName,"fc1") ) { fc1=inValue.Cast<  ::openfl::_Vector::AbstractVector >(); return inValue; }
		if (HX_FIELD_EQ(inName,"red") ) { red=inValue.Cast< Float >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"blue") ) { blue=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"blur") ) { blur=inValue.Cast< Float >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"green") ) { green=inValue.Cast< Float >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"_color") ) { _color=inValue.Cast<  ::openfl::_Vector::AbstractVector >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void BloomEffect_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("fc0","\x53","\xbc","\x4d","\x00"));
	outFields->push(HX_HCSTRING("fc1","\x54","\xbc","\x4d","\x00"));
	outFields->push(HX_HCSTRING("_color","\xa4","\xb8","\x43","\x46"));
	outFields->push(HX_HCSTRING("red","\x51","\xd9","\x56","\x00"));
	outFields->push(HX_HCSTRING("green","\xc3","\x0e","\xed","\x99"));
	outFields->push(HX_HCSTRING("blue","\x9a","\x42","\x19","\x41"));
	outFields->push(HX_HCSTRING("blur","\xa7","\x42","\x19","\x41"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo BloomEffect_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*::openfl::_Vector::AbstractVector*/ ,(int)offsetof(BloomEffect_obj,fc0),HX_HCSTRING("fc0","\x53","\xbc","\x4d","\x00")},
	{hx::fsObject /*::openfl::_Vector::AbstractVector*/ ,(int)offsetof(BloomEffect_obj,fc1),HX_HCSTRING("fc1","\x54","\xbc","\x4d","\x00")},
	{hx::fsObject /*::openfl::_Vector::AbstractVector*/ ,(int)offsetof(BloomEffect_obj,_color),HX_HCSTRING("_color","\xa4","\xb8","\x43","\x46")},
	{hx::fsFloat,(int)offsetof(BloomEffect_obj,red),HX_HCSTRING("red","\x51","\xd9","\x56","\x00")},
	{hx::fsFloat,(int)offsetof(BloomEffect_obj,green),HX_HCSTRING("green","\xc3","\x0e","\xed","\x99")},
	{hx::fsFloat,(int)offsetof(BloomEffect_obj,blue),HX_HCSTRING("blue","\x9a","\x42","\x19","\x41")},
	{hx::fsFloat,(int)offsetof(BloomEffect_obj,blur),HX_HCSTRING("blur","\xa7","\x42","\x19","\x41")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *BloomEffect_obj_sStaticStorageInfo = 0;
#endif

static ::String BloomEffect_obj_sMemberFields[] = {
	HX_HCSTRING("fc0","\x53","\xbc","\x4d","\x00"),
	HX_HCSTRING("fc1","\x54","\xbc","\x4d","\x00"),
	HX_HCSTRING("_color","\xa4","\xb8","\x43","\x46"),
	HX_HCSTRING("red","\x51","\xd9","\x56","\x00"),
	HX_HCSTRING("green","\xc3","\x0e","\xed","\x99"),
	HX_HCSTRING("blue","\x9a","\x42","\x19","\x41"),
	HX_HCSTRING("blur","\xa7","\x42","\x19","\x41"),
	HX_HCSTRING("createProgram","\xe8","\x22","\x3c","\xdc"),
	HX_HCSTRING("beforeDraw","\x23","\x58","\x19","\x91"),
	::String(null()) };

static void BloomEffect_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(BloomEffect_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void BloomEffect_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(BloomEffect_obj::__mClass,"__mClass");
};

#endif

hx::Class BloomEffect_obj::__mClass;

void BloomEffect_obj::__register()
{
	hx::Object *dummy = new BloomEffect_obj;
	BloomEffect_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("haxegon.filters.BloomEffect","\xd3","\x50","\x03","\xce");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = BloomEffect_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(BloomEffect_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< BloomEffect_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = BloomEffect_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = BloomEffect_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = BloomEffect_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace haxegon
} // end namespace filters
